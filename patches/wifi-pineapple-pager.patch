diff --git a/.gitignore b/.gitignore
index 5c97fe3..342f24c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,4 +12,4 @@ Build/
 # Binary output (not the source directory)
 /doomgeneric/doomgeneric
 doomgeneric.map
-*.wad
+*.wad
\ No newline at end of file
diff --git a/doomgeneric/Makefile.mipsel b/doomgeneric/Makefile.mipsel
index 4ee4166..0ccf642 100644
--- a/doomgeneric/Makefile.mipsel
+++ b/doomgeneric/Makefile.mipsel
@@ -11,32 +11,136 @@ else
 endif
 
 # OpenWrt SDK musl-based cross-compiler for mipsel_24kc
-# Using QEMU wrapper to run x86-64 SDK on ARM64 host
+# Default: Use SDK directly (supports LTO, better optimization)
+# Set USE_QEMU_CC=1 to use QEMU wrapper instead (for debugging)
+ifdef USE_QEMU_CC
 CC=$(shell pwd)/qemu-gcc-wrapper.sh
 CROSS_COMPILE=$(shell pwd)/qemu-gcc-wrapper.sh
-# Keep Doom at 320x200 internally, we scale in output code
+else
+CC=mipsel-openwrt-linux-musl-gcc
+CROSS_COMPILE=mipsel-openwrt-linux-musl-
+endif
+# =============================================================================
+# POTATO MODE - Low resolution rendering for maximum performance
+# =============================================================================
+# Uses Doom's built-in low-detail mode (pixel doubling) rather than changing
+# internal resolution. This keeps all game math working correctly.
+#
+# POTATO_MODE=1 : Half-width (160 effective columns, 2x horizontal pixels)
+# POTATO_MODE=2 : Quarter mode (adds 2x vertical pixels too)
+# Default: Full resolution (320x200)
+#
+# Keep internal resolution at 320x200 - potato mode uses pixel doubling
 CFLAGS+=-DDOOMGENERIC_RESX=320 -DDOOMGENERIC_RESY=200
-# Widen FOV to compensate for aspect ratio stretch (480/320)/(222/200) = 1.35x
-# Original FOV is 2048, adjusted: 2048 * 1.35 = 2765
+# Widen FOV to compensate for aspect ratio stretch
 CFLAGS+=-DFIELDOFVIEW=2765
-# Optimize for speed
-# -O3: Maximum speed optimization
-# -march=24kec: Target MIPS 24KEc CPU with DSP extensions
-# -mdsp: Enable MIPS DSP ASE instructions
-# -funroll-loops: Unroll loops for speed
-# -ffast-math: Faster floating point
-# -fomit-frame-pointer: Free up a register
-# -fprefetch-loop-arrays: Generate prefetch instructions for arrays (CPU supports it!)
-# -ftree-loop-vectorize: Enable loop vectorization
-# -finline-functions: Inline small functions for speed
-# -mbranch-likely: Use branch likely instructions for better branch prediction
+
+ifdef POTATO_MODE
+ifeq ($(POTATO_MODE),2)
+CFLAGS+=-DPOTATO_MODE=2
+$(info Building POTATO MODE 2: Quarter resolution (2x2 chunky pixels))
+else
+CFLAGS+=-DPOTATO_MODE=1
+$(info Building POTATO MODE 1: Half-width (2x horizontal chunky pixels))
+endif
+endif
+# =============================================================================
+# COMPILER OPTIMIZATION FLAGS - Based on quantitative A/B testing
+# See perf/OPTIMIZATION_RESEARCH.md for test data
+# =============================================================================
+#
+# TESTED GOOD:
+#   -O3, -flto, -march=24kec, -mtune=24kec, -mbranch-likely
+#   -ffast-math, -funroll-loops, -fomit-frame-pointer, -finline-functions
+#   -fprefetch-loop-arrays (GCC auto-prefetch for all loops)
+#
+# TESTED BAD:
+#   -mdsp: Negative performance impact in testing
+#   Manual render prefetch: 35% SLOWER due to lookup-table cache pollution
+#
 CFLAGS+=-O3 -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
-CFLAGS+=-march=24kec -mtune=24kec -mdsp -mbranch-likely
+CFLAGS+=-march=24kec -mtune=24kec -mbranch-likely
 CFLAGS+=-ffast-math -funroll-loops -fomit-frame-pointer
-CFLAGS+=-fprefetch-loop-arrays -finline-functions
+CFLAGS+=-finline-functions
+
+# LTO: ON by default (10% smaller binary, 17% fewer wasted NOPs)
+# Disable with NO_LTO=1 for faster builds during development
+ifndef NO_LTO
+CFLAGS+=-flto
+LDFLAGS+=-flto
+endif
+
+# GCC auto-prefetch: ON by default
+# Adds ~150 prefetch instructions across all loops (game logic, rendering, etc.)
+# MIPS 24KEc queues prefetch during idle cycles - essentially "free"
+# Disable with NO_GCC_PREFETCH=1 for testing
+ifndef NO_GCC_PREFETCH
+CFLAGS+=-fprefetch-loop-arrays
+endif
+
+# Manual render prefetch: OFF permanently
+# PROVEN 35% SLOWER in microbenchmark - lookup-table pattern pollutes cache
+# See perf/PREFETCH_ANALYSIS.md for details
+
+# Cache-aligned arrays: ON by default for hot rendering arrays (vissprites, drawsegs)
+# Disable with NO_CACHE_ALIGN=1
+# NOTE: Only 2 arrays aligned - more alignment tested worse (++ vs +++)
+ifndef NO_CACHE_ALIGN
+CFLAGS+=-DCACHE_ALIGN_ARRAYS
+endif
+
+# GCC cache hints: OFF by default (tested, reduced PREF 149->70, scored ++ vs +++)
+# Enable with CACHE_HINTS=1 to try: --param=l1-cache-size=16 --param=l1-cache-line-size=32
+ifdef CACHE_HINTS
+CFLAGS+=--param=l1-cache-size=16 --param=l1-cache-line-size=32
+CFLAGS+=--param=simultaneous-prefetches=2
+endif
+
+# Differential copy: FastDoom-style frame diffing
+# Only writes changed rows to display, reducing SPI bandwidth
+# Enable with DIFF_COPY=1
+ifdef DIFF_COPY
+CFLAGS+=-DDIFF_COPY_ENABLED
+endif
+
 LDFLAGS+=-static
 LIBS+=-lm -lc
 
+# =============================================================================
+# PAGER OPTIMIZATION FLAGS
+# =============================================================================
+#
+# DEFAULT CONFIGURATION (optimized based on quantitative A/B testing):
+#   - LTO enabled (-flto)
+#   - GCC auto-prefetch ENABLED (-fprefetch-loop-arrays) - ~150 pref instructions
+#   - Manual render prefetch DISABLED - proven 35% slower (cache pollution)
+#   - Cache-aligned arrays ENABLED (-DCACHE_ALIGN_ARRAYS) - vissprites, drawsegs
+#   - Cache-optimized mobj_t layout ENABLED
+#   - HOT_FUNC attributes on render/game loop functions
+#
+# See perf/OPTIMIZATION_RESEARCH.md and perf/PREFETCH_ANALYSIS.md
+#
+# -----------------------------------------------------------------------------
+# BENCHMARK RESULTS (real framebuffer microbenchmark)
+# -----------------------------------------------------------------------------
+#   No prefetch:              3574 us/frame (baseline)
+#   GCC auto-prefetch:        ~3500 us/frame (+2% - helps game logic)
+#   Manual render prefetch:   4820 us/frame (-35% SLOWER!)
+#
+# -----------------------------------------------------------------------------
+# COMPILE-TIME OPTIONS
+# -----------------------------------------------------------------------------
+#   NO_GCC_PREFETCH=1          Disable GCC auto-prefetch (for testing)
+#   -DDISABLE_FRAME_CAP        Uncapped framerate (for benchmarking)
+#   -DENABLE_FPS_DEBUG         Enable FPS logging to /tmp/fps.log
+#   -DENABLE_VSYNC             Force fsync after write (~10 FPS, no tearing)
+#   -DINLINE_FIXED_MATH        Inline FixedMul/FixedDiv
+#   -DCOLUMN_PREFETCH_ENABLED  Prefetch texture in R_DrawColumn
+#
+ifdef EXTRA_CFLAGS
+CFLAGS+=$(EXTRA_CFLAGS)
+endif
+
 # subdirectory for objects
 OBJDIR=build
 OUTPUT=doomgeneric
diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index 3791649..5b87763 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -8,6 +8,7 @@
 #include "i_system.h"
 #include "doomdef.h"   // For GS_LEVEL constant
 #include "doomstat.h"  // For gamestate variable
+#include "pager_opts.h"  // PAGER: function attributes
 
 // XXX: HACK
 // Linux's input-event-codes.h and doomkeys.h have many collisions.
@@ -57,6 +58,7 @@
 #include <dirent.h>
 #include <sys/mman.h>
 #include <sys/time.h>
+#include <time.h>
 #include <sys/ioctl.h>
 #include <linux/input.h>
 #include <linux/input-event-codes.h>
@@ -96,24 +98,28 @@ static inline void *aligned_alloc_cached(size_t size) {
 // timing stuff
 static struct timeval startTime;
 
-// FPS and timing tracking (writes to file, not stderr - stderr crashes SIGIL!)
+// Compile-time debug/perf options (enable via -D flags in Makefile):
+// -DENABLE_VSYNC       - fsync after write (no tearing but ~10 FPS) 
+// -DENABLE_FPS_DEBUG   - FPS logging to /tmp/fps.log
+// -DDISABLE_FRAME_CAP  - Uncapped framerate (for benchmarking)
+
+#ifdef ENABLE_FPS_DEBUG
 static uint32_t frameCount = 0;
 static uint32_t lastFpsTime = 0;
 static uint32_t currentFps = 0;
-static uint32_t totalWriteTimeMs = 0;  // Accumulated write() time
-static uint32_t avgWriteTimeMs = 0;    // Average write time per frame
-static int useVsync = 0;               // If 1, fsync after write (no tearing but ~10 FPS)
-static int fpsFd = -1;                 // File descriptor for FPS logging
-static int useFpsDebug = 0;            // If 1, enable FPS logging (disabled by default)
-#define FPS_UPDATE_INTERVAL_MS 1000  // Update FPS every second
-
-// Frame rate cap - default 35 FPS (DOOM's native TICRATE)
-// Configurable via -fps N (0 = uncapped, 20 = Pager display, 35 = DOOM native)
+static uint32_t totalWriteTimeMs = 0;
+static uint32_t avgWriteTimeMs = 0;
+static int fpsFd = -1;
+#define FPS_UPDATE_INTERVAL_MS 1000
+#endif
+
+// Frame rate cap - 35 FPS (DOOM's native TICRATE)
+// Uses clock_nanosleep with absolute timing for precise, consistent frame pacing
+#ifndef DISABLE_FRAME_CAP
 #define DEFAULT_TARGET_FPS 35
-static int targetFps = DEFAULT_TARGET_FPS;
-static int frameTimeMs = (1000 / DEFAULT_TARGET_FPS);  // ~28ms
-static uint32_t lastFrameTime = 0;
-static int useFrameCap = 1;    // Enabled by default (35 FPS)
+static long frameTimeNs = 1000000000L / DEFAULT_TARGET_FPS;  // ~28.57ms
+static struct timespec nextFrameTime;
+#endif
 
 // framebuffer stuff 
 static uint8_t *fbPtr;
@@ -153,7 +159,9 @@ static void cleanup_and_exit(int sig) {
 	if (srcYLookup) free(srcYLookup);
 	if (srcXLookupAspect) free(srcXLookupAspect);
 	if (srcYLookupAspect) free(srcYLookupAspect);
+#ifdef ENABLE_FPS_DEBUG
 	if (fpsFd >= 0) close(fpsFd);
+#endif
 	if (fbFd >= 0) close(fbFd);
 	_exit(sig ? 128 + sig : 0);
 }
@@ -181,9 +189,11 @@ static int dpadRightPressed = 0;
 // Track active combo key (to release when Green is released)
 static int comboKeyActive = 0;
 
-// Prefetch optimization - enabled by default for better cache performance
-// Use -noprefetch to disable if issues occur
-static int usePrefetch = 1;
+// Prefetch optimization - compile-time control
+// DISABLED BY DEFAULT: Microbenchmark proved 35% SLOWER due to
+// non-sequential lookup table access pattern polluting 32KB L1 cache.
+// Enable with -DUSE_RENDER_PREFETCH=1 only for testing.
+// See: perf/PREFETCH_ANALYSIS.md
 
 // XXX: HACK
 // Linux's evdev system doesn't make it feasible to just use
@@ -664,40 +674,19 @@ void DG_Init() {
 	struct fb_var_screeninfo info;
 	struct fb_fix_screeninfo finfo;
 
-	// Check for -vsync command line arg (uses fsync for tear-free but ~10 FPS)
-	if (M_CheckParm("-vsync")) {
-		useVsync = 1;
-		printf("VSync enabled (tear-free but slower)\n");
-	}
-	
-	// Prefetch control (enabled by default for better cache performance)
-	if (M_CheckParm("-noprefetch")) {
-		usePrefetch = 0;
-		printf("Prefetch disabled\n");
-	}
-
-	// Check for -fps N to override default frame rate cap
-	// Default: 35 FPS (DOOM native). Use -fps 0 for uncapped.
-	int fpsArg = M_CheckParmWithArgs("-fps", 1);
-	if (fpsArg) {
-		targetFps = atoi(myargv[fpsArg + 1]);
-		if (targetFps > 0) {
-			useFrameCap = 1;
-			frameTimeMs = 1000 / targetFps;
-			printf("Frame cap: %d FPS (%dms/frame)\n", targetFps, frameTimeMs);
-		} else {
-			useFrameCap = 0;
-			printf("Uncapped framerate\n");
-		}
-	} else {
-		printf("Frame cap: %d FPS (default, use -fps N to change)\n", DEFAULT_TARGET_FPS);
-	}
-
-	// Check for -fpsdebug to enable FPS logging
-	if (M_CheckParm("-fpsdebug")) {
-		useFpsDebug = 1;
-		printf("FPS debug logging enabled (/tmp/fps.log)\n");
-	}
+	// Print compile-time config
+#ifdef ENABLE_VSYNC
+	printf("VSync: enabled (compile-time)\n");
+#endif
+#ifdef DISABLE_FRAME_CAP
+	printf("Frame cap: disabled (compile-time)\n");
+#else
+	printf("Frame cap: %d FPS\n", DEFAULT_TARGET_FPS);
+	clock_gettime(CLOCK_MONOTONIC, &nextFrameTime);
+#endif
+#ifdef ENABLE_FPS_DEBUG
+	printf("FPS debug: enabled (/tmp/fps.log)\n");
+#endif
 
 	// Set up signal handlers for clean exit
 	signal(SIGINT, cleanup_and_exit);
@@ -862,17 +851,17 @@ static inline uint16_t rgb32_to_rgb565(uint32_t pixel) {
 	return ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
 }
 
-void DG_DrawFrame() {
-	// Frame rate cap - don't render faster than target FPS
-	// This provides consistent frame timing and reduces CPU usage
-	if (useFrameCap) {
-		uint32_t now = DG_GetTicksMs();
-		uint32_t elapsed = now - lastFrameTime;
-		if (elapsed < (uint32_t)frameTimeMs) {
-			usleep((frameTimeMs - elapsed) * 1000);
-		}
-		lastFrameTime = DG_GetTicksMs();
+HOT_FUNC void DG_DrawFrame() {
+#ifndef DISABLE_FRAME_CAP
+	// Frame rate cap using clock_nanosleep with absolute timing
+	// Provides precise, consistent frame pacing without drift
+	nextFrameTime.tv_nsec += frameTimeNs;
+	if (nextFrameTime.tv_nsec >= 1000000000L) {
+		nextFrameTime.tv_nsec -= 1000000000L;
+		nextFrameTime.tv_sec++;
 	}
+	clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &nextFrameTime, NULL);
+#endif
 
 	if (fbIs16Bit) {
 		// OPTIMIZED 16-bit RGB565 path with 90Â° CCW rotation
@@ -884,9 +873,8 @@ void DG_DrawFrame() {
 		const uint16_t *palette = rgb565_palette;
 		
 		// Use aspect-correct rendering for title/menu screens, stretched for gameplay
-		int useAspectCorrect = (gamestate != GS_LEVEL);
-		
-		if (useAspectCorrect && srcXLookupAspect && srcYLookupAspect) {
+		// UNLIKELY: gameplay (GS_LEVEL) is far more common than menus
+		if (UNLIKELY(gamestate != GS_LEVEL) && srcXLookupAspect && srcYLookupAspect) {
 			// Clear buffer first (for black bars at top/bottom)
 			memset(renderBuffer, 0, renderBufferSize);
 			
@@ -897,18 +885,22 @@ void DG_DrawFrame() {
 				unsigned int srcX = srcXLookupAspect[y];
 				const unsigned int *yLookup = srcYLookupAspect;
 				
-				// Prefetch next row's lookup value
-				if (usePrefetch && y + 1 < aspectOutH) {
-					__builtin_prefetch(&srcXLookupAspect[y + 1], 0, 3);
+#ifdef USE_RENDER_PREFETCH
+				// Prefetch lookup table 8 entries ahead (32-byte cache line = 8 ints)
+				if (y + 8 < aspectOutH) {
+					__builtin_prefetch(&srcXLookupAspect[y + 8], 0, 3);
 				}
+#endif
 				
 				// Process 4 pixels at a time with direct palette lookup
 				unsigned int x = 0;
 				for (; x + 3 < aspectOutW; x += 4) {
+#ifdef USE_RENDER_PREFETCH
 					// Prefetch ahead in source buffer
-					if (usePrefetch && x + 16 < aspectOutW) {
+					if (x + 16 < aspectOutW) {
 						__builtin_prefetch(&srcBuf[yLookup[x+16] * DOOMGENERIC_RESX + srcX], 0, 0);
 					}
+#endif
 					dst[x]   = palette[srcBuf[yLookup[x]   * DOOMGENERIC_RESX + srcX]];
 					dst[x+1] = palette[srcBuf[yLookup[x+1] * DOOMGENERIC_RESX + srcX]];
 					dst[x+2] = palette[srcBuf[yLookup[x+2] * DOOMGENERIC_RESX + srcX]];
@@ -921,24 +913,28 @@ void DG_DrawFrame() {
 			}
 		} else {
 			// Full-screen stretched rendering (gameplay with FOV correction)
-			// Direct palette lookup from I_VideoBuffer
+			// Nearest-neighbor scaling: crisp pixels, authentic retro look
 			for (unsigned int y = 0; y < scaledOutH; y++) {
 				uint16_t *dst = renderBuffer + (y + scaledOffY) * fbWidth;
 				unsigned int srcX = srcXLookup[y];
 				const unsigned int *yLookup = srcYLookup;
 				
-				// Prefetch next row's lookup value
-				if (usePrefetch && y + 1 < scaledOutH) {
-					__builtin_prefetch(&srcXLookup[y + 1], 0, 3);
+#ifdef USE_RENDER_PREFETCH
+				// Prefetch lookup table 8 entries ahead (32-byte cache line = 8 ints)
+				if (y + 8 < scaledOutH) {
+					__builtin_prefetch(&srcXLookup[y + 8], 0, 3);
 				}
+#endif
 				
 				// Process 4 pixels at a time with direct palette lookup
 				unsigned int x = 0;
 				for (; x + 3 < scaledOutW; x += 4) {
+#ifdef USE_RENDER_PREFETCH
 					// Prefetch ahead in source buffer
-					if (usePrefetch && x + 16 < scaledOutW) {
+					if (x + 16 < scaledOutW) {
 						__builtin_prefetch(&srcBuf[yLookup[x+16] * DOOMGENERIC_RESX + srcX], 0, 0);
 					}
+#endif
 					dst[x]   = palette[srcBuf[yLookup[x]   * DOOMGENERIC_RESX + srcX]];
 					dst[x+1] = palette[srcBuf[yLookup[x+1] * DOOMGENERIC_RESX + srcX]];
 					dst[x+2] = palette[srcBuf[yLookup[x+2] * DOOMGENERIC_RESX + srcX]];
@@ -951,14 +947,18 @@ void DG_DrawFrame() {
 			}
 		}
 		
-		// Write frame to display (measure time)
+		// Write frame to display
+#ifdef ENABLE_FPS_DEBUG
 		uint32_t writeStart = DG_GetTicksMs();
+#endif
 		lseek(fbFd, 0, SEEK_SET);
 		write(fbFd, renderBuffer, renderBufferSize);
-		if (useVsync) {
-			fsync(fbFd);  // Wait for SPI transfer (~95ms, ~10 FPS but no tearing)
-		}
+#ifdef ENABLE_VSYNC
+		fsync(fbFd);  // Wait for SPI transfer (~95ms, ~10 FPS but no tearing)
+#endif
+#ifdef ENABLE_FPS_DEBUG
 		totalWriteTimeMs += DG_GetTicksMs() - writeStart;
+#endif
 	} else {
 		// Original 32-bit mmap path
 		for (int line = 0; line < DOOMGENERIC_RESY; line++) {
@@ -970,30 +970,28 @@ void DG_DrawFrame() {
 		}
 	}
 
-	// FPS tracking - only when -fpsdebug is enabled
-	// Writes to file (stderr causes SIGIL to crash!)
-	if (useFpsDebug) {
-		frameCount++;
-		uint32_t now = DG_GetTicksMs();
-		if (now - lastFpsTime >= FPS_UPDATE_INTERVAL_MS) {
-			currentFps = (frameCount * 1000) / (now - lastFpsTime);
-			avgWriteTimeMs = frameCount > 0 ? totalWriteTimeMs / frameCount : 0;
-			uint32_t displayFps = avgWriteTimeMs > 0 ? 1000 / avgWriteTimeMs : 0;
-			// Write to file instead of stderr - stderr causes crashes on intensive maps
-			if (fpsFd < 0) {
-				fpsFd = open("/tmp/fps.log", O_WRONLY | O_CREAT | O_TRUNC, 0644);
-			}
-			if (fpsFd >= 0) {
-				char buf[64];
-				int len = snprintf(buf, sizeof(buf), "FPS: %u | write: %ums | display: ~%u fps\n", 
-					currentFps, avgWriteTimeMs, displayFps);
-				write(fpsFd, buf, len);
-			}
-			frameCount = 0;
-			totalWriteTimeMs = 0;
-			lastFpsTime = now;
+#ifdef ENABLE_FPS_DEBUG
+	// FPS tracking - writes to file (stderr causes SIGIL to crash!)
+	frameCount++;
+	uint32_t now = DG_GetTicksMs();
+	if (now - lastFpsTime >= FPS_UPDATE_INTERVAL_MS) {
+		currentFps = (frameCount * 1000) / (now - lastFpsTime);
+		avgWriteTimeMs = frameCount > 0 ? totalWriteTimeMs / frameCount : 0;
+		uint32_t displayFps = avgWriteTimeMs > 0 ? 1000 / avgWriteTimeMs : 0;
+		if (fpsFd < 0) {
+			fpsFd = open("/tmp/fps.log", O_WRONLY | O_CREAT | O_TRUNC, 0644);
+		}
+		if (fpsFd >= 0) {
+			char buf[64];
+			int len = snprintf(buf, sizeof(buf), "FPS: %u | write: %ums | display: ~%u fps\n", 
+				currentFps, avgWriteTimeMs, displayFps);
+			write(fpsFd, buf, len);
 		}
+		frameCount = 0;
+		totalWriteTimeMs = 0;
+		lastFpsTime = now;
 	}
+#endif
 
 	checkKeys();
 }
@@ -1035,7 +1033,8 @@ int DG_GetKey(int* pressed, unsigned char* doomKey) {
 }
 
 void DG_SetWindowTitle(const char * title) {
-	printf("Window Title: %s\n", title);
+	// Silenced - no window in framebuffer mode
+	(void)title;
 }
 
 int main(int argc, char **argv) {
diff --git a/doomgeneric/g_game.c b/doomgeneric/g_game.c
index 20eca54..8f298a5 100644
--- a/doomgeneric/g_game.c
+++ b/doomgeneric/g_game.c
@@ -24,6 +24,7 @@
 #include "doomdef.h" 
 #include "doomkeys.h"
 #include "doomstat.h"
+#include "pager_opts.h"  // PAGER: function attributes
 
 #include "deh_main.h"
 #include "deh_misc.h"
@@ -851,7 +852,7 @@ boolean G_Responder (event_t* ev)
 // G_Ticker
 // Make ticcmd_ts for the players.
 //
-void G_Ticker (void) 
+HOT_FUNC void G_Ticker (void) 
 { 
     int		i;
     int		buf; 
diff --git a/doomgeneric/m_fixed.c b/doomgeneric/m_fixed.c
index 23f6ff3..faea90c 100644
--- a/doomgeneric/m_fixed.c
+++ b/doomgeneric/m_fixed.c
@@ -16,8 +16,6 @@
 //	Fixed point implementation.
 //
 
-
-
 #include "stdlib.h"
 
 #include "doomtype.h"
@@ -25,10 +23,12 @@
 
 #include "m_fixed.h"
 
-
-
-
-// Fixme. __USE_C_FIXED__ or something.
+//
+// When INLINE_FIXED_MATH is defined, these functions are provided as
+// static inline in m_fixed.h instead. This file is still compiled but
+// the functions are excluded to avoid duplicate symbols.
+//
+#ifndef INLINE_FIXED_MATH
 
 fixed_t
 FixedMul
@@ -38,8 +38,6 @@ FixedMul
     return ((int64_t) a * (int64_t) b) >> FRACBITS;
 }
 
-
-
 //
 // FixedDiv, C version.
 //
@@ -60,3 +58,5 @@ fixed_t FixedDiv(fixed_t a, fixed_t b)
     }
 }
 
+#endif // !INLINE_FIXED_MATH
+
diff --git a/doomgeneric/m_fixed.h b/doomgeneric/m_fixed.h
index 733b290..2115fdf 100644
--- a/doomgeneric/m_fixed.h
+++ b/doomgeneric/m_fixed.h
@@ -20,8 +20,9 @@
 #ifndef __M_FIXED__
 #define __M_FIXED__
 
-
-
+#include <stdint.h>
+#include <stdlib.h>
+#include <limits.h>
 
 //
 // Fixed point, 32bit as 16.16.
@@ -31,9 +32,40 @@
 
 typedef int fixed_t;
 
-fixed_t FixedMul	(fixed_t a, fixed_t b);
-fixed_t FixedDiv	(fixed_t a, fixed_t b);
+//
+// PAGER OPTIMIZATION: Inline fixed-point math
+//
+// When INLINE_FIXED_MATH is defined, FixedMul and FixedDiv are inlined.
+// This eliminates function call overhead on 165+ call sites in hot paths
+// (rendering, collision, AI).
+//
+// Source: FastDoom, GZDoom optimization techniques
+// Expected gain: 5-10% in hot code paths
+//
+// Compile with: -DINLINE_FIXED_MATH
+//
+#ifdef INLINE_FIXED_MATH
+
+static inline fixed_t FixedMul(fixed_t a, fixed_t b)
+{
+    return (fixed_t)(((int64_t)a * (int64_t)b) >> FRACBITS);
+}
+
+static inline fixed_t FixedDiv(fixed_t a, fixed_t b)
+{
+    if ((abs(a) >> 14) >= abs(b))
+    {
+        return (a ^ b) < 0 ? INT_MIN : INT_MAX;
+    }
+    return (fixed_t)(((int64_t)a << FRACBITS) / b);
+}
+
+#else
 
+// Standard function declarations (implementations in m_fixed.c)
+fixed_t FixedMul(fixed_t a, fixed_t b);
+fixed_t FixedDiv(fixed_t a, fixed_t b);
 
+#endif // INLINE_FIXED_MATH
 
-#endif
+#endif // __M_FIXED__
diff --git a/doomgeneric/m_menu.c b/doomgeneric/m_menu.c
index 4feb72c..1c44f04 100644
--- a/doomgeneric/m_menu.c
+++ b/doomgeneric/m_menu.c
@@ -74,7 +74,12 @@ int			showMessages = 1;
 	
 
 // Blocky mode, has default, 0 = high, 1 = normal
-int			detailLevel = 0;
+// POTATO_MODE forces low detail (chunky pixels) for better performance
+#ifdef POTATO_MODE
+int			detailLevel = 1;  // Low detail - pixel doubling
+#else
+int			detailLevel = 0;  // High detail - normal
+#endif
 int			screenblocks = 10;
 
 // temp for screenblocks (0-9)
diff --git a/doomgeneric/p_enemy.c b/doomgeneric/p_enemy.c
index f2b44d1..25a06cc 100644
--- a/doomgeneric/p_enemy.c
+++ b/doomgeneric/p_enemy.c
@@ -654,10 +654,72 @@ void A_Look (mobj_t* actor)
 // Actor has a melee attack,
 // so it tries to close as fast as possible
 //
+// PAGER OPTIMIZATION: Distance-based AI throttling
+//
+// Two modes available:
+//
+// AI_THROTTLE_SIMPLE (FastDoom-style):
+//   Enemies >1024 units (~32 map units) think every 2nd tic
+//   Simple, minimal overhead, good for most cases
+//
+// AI_THROTTLE_TIERED (Custom 3-tier):
+//   Near (<32 units): every tic
+//   Mid (32-64 units): every 2nd tic  
+//   Far (>128 units): every 4th tic
+//   More aggressive, better for crowded maps
+//
+// Source: FastDoom AI optimization
+// Expected gain: 10-15% game logic reduction
+//
+// Compile with: -DAI_THROTTLE_SIMPLE or -DAI_THROTTLE_TIERED
+//
+#ifdef AI_THROTTLE_TIERED
+#define AI_THROTTLE_DIST_MID    (2048 << FRACBITS)  // ~64 map units
+#define AI_THROTTLE_DIST_FAR    (4096 << FRACBITS)  // ~128 map units
+#endif
+
 void A_Chase (mobj_t*	actor)
 {
     int		delta;
 
+#ifdef AI_THROTTLE_SIMPLE
+    // FastDoom-style: simple distance check
+    // Enemies >1024 units away think every 2nd tic
+    if (actor->target && players[0].mo)
+    {
+        fixed_t dist = P_AproxDistance(actor->x - players[0].mo->x,
+                                       actor->y - players[0].mo->y);
+        if (dist > (1024 << FRACBITS) && (leveltime & 1))
+            return;
+    }
+#endif
+
+#ifdef AI_THROTTLE_TIERED
+    // 3-tier distance-based AI throttling
+    if (actor->target && players[0].mo)
+    {
+        fixed_t dist = P_AproxDistance(actor->x - players[0].mo->x,
+                                       actor->y - players[0].mo->y);
+        
+        // Use actor pointer as pseudo-random offset
+        int actor_offset = ((size_t)actor >> 4) & 0x3;
+        
+        if (dist > AI_THROTTLE_DIST_FAR)
+        {
+            // Very far: think every 4th tic
+            if (((leveltime + actor_offset) & 3) != 0)
+                return;
+        }
+        else if (dist > AI_THROTTLE_DIST_MID)
+        {
+            // Medium distance: think every 2nd tic
+            if (((leveltime + actor_offset) & 1) != 0)
+                return;
+        }
+        // Near enemies: always think
+    }
+#endif
+
     if (actor->reactiontime)
 	actor->reactiontime--;
 				
diff --git a/doomgeneric/p_mobj.h b/doomgeneric/p_mobj.h
index 90ed764..fb5efb2 100644
--- a/doomgeneric/p_mobj.h
+++ b/doomgeneric/p_mobj.h
@@ -198,87 +198,113 @@ typedef enum
 
 
 // Map Object definition.
+//
+// PAGER OPTIMIZATION: Cache-optimized field ordering
+//
+// When MOBJ_CACHE_OPTIMIZE is defined (default), hot fields are grouped
+// in first 3 cache lines (~96 bytes) to minimize cache misses.
+//
+// When MOBJ_ORIGINAL_LAYOUT is defined, use vanilla Doom field order
+// for A/B benchmarking comparison.
+//
+// MIPS 24KEc: 32KB L1 D-cache, 32-byte lines, no L2
+// Every L1 miss goes to main memory (~100+ cycles)
+//
+// Compile with: -DMOBJ_ORIGINAL_LAYOUT to disable optimization
+//
+#ifdef MOBJ_ORIGINAL_LAYOUT
+
+// ORIGINAL vanilla Doom field order (for A/B testing)
+// Hot fields scattered across 7 cache lines = many cache misses
 typedef struct mobj_s
 {
-    // List: thinker links.
-    thinker_t		thinker;
+    thinker_t       thinker;        // Thinker links (MUST be first)
+    fixed_t         x, y, z;        // Position
+    struct mobj_s*  snext;          // Sector links
+    struct mobj_s*  sprev;
+    angle_t         angle;          // Orientation
+    spritenum_t     sprite;         // Rendering
+    int             frame;
+    struct mobj_s*  bnext;          // Block links
+    struct mobj_s*  bprev;
+    struct subsector_s* subsector;
+    fixed_t         floorz;         // Movement bounds
+    fixed_t         ceilingz;
+    fixed_t         radius;         // Collision
+    fixed_t         height;
+    fixed_t         momx, momy, momz; // Momentum
+    int             validcount;
+    mobjtype_t      type;
+    mobjinfo_t*     info;
+    int             tics;           // Animation
+    state_t*        state;
+    int             flags;
+    int             health;
+    int             movedir;        // AI
+    int             movecount;
+    struct mobj_s*  target;
+    int             reactiontime;
+    int             threshold;
+    struct player_s* player;
+    int             lastlook;
+    mapthing_t      spawnpoint;
+    struct mobj_s*  tracer;
+} mobj_t;
 
-    // Info for drawing: position.
-    fixed_t		x;
+#else
+
+// CACHE OPTIMIZED LAYOUT for MIPS 24KEc (32-byte cache lines)
+// Hot fields grouped in first 3 cache lines (~96 bytes)
+typedef struct mobj_s
+{
+    // === CACHE LINE 0 (bytes 0-31): Core position & state ===
+    // thinker MUST be first - code casts thinker_t* to mobj_t*
+    thinker_t		thinker;	// 12 bytes: linked list for P_RunThinkers
+    fixed_t		x;		// Position - accessed in collision, rendering, AI
     fixed_t		y;
     fixed_t		z;
+    int			flags;		// Checked in almost every function
+    int			tics;		// Animation counter - checked every frame
 
-    // More list: links in sector (if needed)
+    // === CACHE LINE 1 (bytes 32-63): Animation, movement, collision ===
+    state_t*		state;		// Animation state
+    mobjinfo_t*		info;		// Object type info (stats, AI params)
+    fixed_t		momx;		// Momentum - movement every tick
+    fixed_t		momy;
+    fixed_t		momz;
+    fixed_t		radius;		// Collision bounds - checked constantly
+    fixed_t		height;
+    angle_t		angle;		// Rendering orientation
+
+    // === CACHE LINE 2 (bytes 64-95): Rendering, AI, type ===
+    spritenum_t		sprite;		// Rendering
+    int			frame;		// Rendering (might be ORed with FF_FULLBRIGHT)
+    int			health;		// Combat
+    struct mobj_s*	target;		// AI target / missile originator
+    int			validcount;	// Iteration guard
+    mobjtype_t		type;		// Object type enum
+    int			movedir;	// AI movement direction (0-7)
+    int			movecount;	// AI movement counter
+
+    // === CACHE LINE 3+ (bytes 96+): Less frequently accessed ===
+    fixed_t		floorz;
+    fixed_t		ceilingz;
+    struct subsector_s*	subsector;
     struct mobj_s*	snext;
     struct mobj_s*	sprev;
-
-    //More drawing info: to determine current sprite.
-    angle_t		angle;	// orientation
-    spritenum_t		sprite;	// used to find patch_t and flip value
-    int			frame;	// might be ORed with FF_FULLBRIGHT
-
-    // Interaction info, by BLOCKMAP.
-    // Links in blocks (if needed).
     struct mobj_s*	bnext;
     struct mobj_s*	bprev;
-    
-    struct subsector_s*	subsector;
-
-    // The closest interval over all contacted Sectors.
-    fixed_t		floorz;
-    fixed_t		ceilingz;
-
-    // For movement checking.
-    fixed_t		radius;
-    fixed_t		height;	
-
-    // Momentums, used to update position.
-    fixed_t		momx;
-    fixed_t		momy;
-    fixed_t		momz;
-
-    // If == validcount, already checked.
-    int			validcount;
-
-    mobjtype_t		type;
-    mobjinfo_t*		info;	// &mobjinfo[mobj->type]
-    
-    int			tics;	// state tic counter
-    state_t*		state;
-    int			flags;
-    int			health;
-
-    // Movement direction, movement generation (zig-zagging).
-    int			movedir;	// 0-7
-    int			movecount;	// when 0, select a new dir
-
-    // Thing being chased/attacked (or NULL),
-    // also the originator for missiles.
-    struct mobj_s*	target;
-
-    // Reaction time: if non 0, don't attack yet.
-    // Used by player to freeze a bit after teleporting.
-    int			reactiontime;   
-
-    // If >0, the target will be chased
-    // no matter what (even if shot)
+    int			reactiontime;
     int			threshold;
-
-    // Additional info record for player avatars only.
-    // Only valid if type == MT_PLAYER
     struct player_s*	player;
-
-    // Player number last looked for.
-    int			lastlook;	
-
-    // For nightmare respawn.
-    mapthing_t		spawnpoint;	
-
-    // Thing being chased/attacked for tracers.
-    struct mobj_s*	tracer;	
+    int			lastlook;
+    mapthing_t		spawnpoint;
+    struct mobj_s*	tracer;
     
 } mobj_t;
 
+#endif // MOBJ_ORIGINAL_LAYOUT
+
 
 
 #endif
diff --git a/doomgeneric/p_tick.c b/doomgeneric/p_tick.c
index 2289350..f9b2f68 100644
--- a/doomgeneric/p_tick.c
+++ b/doomgeneric/p_tick.c
@@ -22,6 +22,7 @@
 #include "p_local.h"
 
 #include "doomstat.h"
+#include "pager_opts.h"  // PAGER: function attributes
 
 
 int	leveltime;
@@ -91,13 +92,49 @@ void P_AllocateThinker (thinker_t*	thinker)
 //
 // P_RunThinkers
 //
-void P_RunThinkers (void)
+// PAGER OPTIMIZATION: Prefetch next thinker(s) while processing current one.
+//
+// When THINKER_PREFETCH_ENABLED is defined, we prefetch the next thinkers
+// in the linked list to hide memory latency.
+//
+// The thinker list is a linked list scattered in heap memory. Each ->next
+// dereference is a potential cache miss (~100+ cycles on MIPS 24KEc).
+// By prefetching 2 thinkers ahead, we hide memory latency.
+//
+// Prefetch strategy:
+// - Prefetch next->next to hide L1 miss latency
+// - Each thinker is at least sizeof(thinker_t) but usually mobj_t (~200 bytes)
+// - MIPS 24KEc has 32KB L1 D-cache with 32-byte lines
+//
+// Source: Cache optimization analysis (perf/CACHE_OPTIMIZATION.md)
+// Expected gain: 5-10% game logic reduction
+//
+// Compile with: -DTHINKER_PREFETCH_ENABLED
+//
+HOT_FUNC void P_RunThinkers (void)
 {
     thinker_t*	currentthinker;
+#ifdef THINKER_PREFETCH_ENABLED
+    thinker_t*	nextthinker;
+#endif
 
     currentthinker = thinkercap.next;
     while (currentthinker != &thinkercap)
     {
+#ifdef THINKER_PREFETCH_ENABLED
+	// Save next pointer before potential Z_Free
+	nextthinker = currentthinker->next;
+	
+	// Prefetch 2 thinkers ahead to hide memory latency
+	// Level 0 = no temporal locality (won't be reused soon)
+	if (nextthinker != &thinkercap) {
+	    __builtin_prefetch(nextthinker, 0, 0);
+	    if (nextthinker->next != &thinkercap) {
+		__builtin_prefetch(nextthinker->next, 0, 0);
+	    }
+	}
+#endif
+
 	if ( currentthinker->function.acv == (actionf_v)(-1) )
 	{
 	    // time to remove it
@@ -110,7 +147,11 @@ void P_RunThinkers (void)
 	    if (currentthinker->function.acp1)
 		currentthinker->function.acp1 (currentthinker);
 	}
+#ifdef THINKER_PREFETCH_ENABLED
+	currentthinker = nextthinker;
+#else
 	currentthinker = currentthinker->next;
+#endif
     }
 }
 
diff --git a/doomgeneric/pager_optimizations.h b/doomgeneric/pager_optimizations.h
new file mode 100644
index 0000000..112c3d1
--- /dev/null
+++ b/doomgeneric/pager_optimizations.h
@@ -0,0 +1,141 @@
+// pager_optimizations.h
+// WiFi Pineapple Pager DOOM Optimizations
+//
+// Compile-time flags to enable/disable individual optimizations.
+// Use -D flags when building to enable specific optimizations.
+//
+// Based on research from:
+// - FastDoom (DOS optimization techniques)
+// - RP2040-doom (embedded rendering)
+// - embeddedDOOM (memory reduction)
+// - Our own benchmarking (see perf/PROMPT.md)
+
+#ifndef PAGER_OPTIMIZATIONS_H
+#define PAGER_OPTIMIZATIONS_H
+
+// ============================================
+// OPTIMIZATION FLAGS
+// ============================================
+
+// INLINE_FIXED_MATH: Inline FixedMul/FixedDiv
+// Eliminates function call overhead on 165+ call sites
+// Source: FastDoom, GZDoom
+// Expected gain: 5-10% in hot paths
+#ifdef INLINE_FIXED_MATH
+#define USE_INLINE_FIXED 1
+#else
+#define USE_INLINE_FIXED 0
+#endif
+
+// AI_THROTTLE_ENABLED: Distance-based AI throttling
+// Reduces think frequency for distant enemies
+// Source: Custom optimization for embedded systems
+// Expected gain: 10-15% game logic
+#ifdef AI_THROTTLE_ENABLED
+#define USE_AI_THROTTLE 1
+#else
+#define USE_AI_THROTTLE 0
+#endif
+
+// THINKER_PREFETCH_ENABLED: Prefetch in P_RunThinkers
+// Prefetch next 2 thinkers to hide memory latency
+// Source: Cache optimization analysis
+// Expected gain: 5-10% game logic
+#ifdef THINKER_PREFETCH_ENABLED
+#define USE_THINKER_PREFETCH 1
+#else
+#define USE_THINKER_PREFETCH 0
+#endif
+
+// DOUBLE_BUFFER_ENABLED: Double buffering for display
+// Render to back buffer while front transfers via SPI
+// Source: RP2040-doom, nRF52840-doom
+// Expected gain: Overlap CPU work with I/O
+#ifdef DOUBLE_BUFFER_ENABLED
+#define USE_DOUBLE_BUFFER 1
+#else
+#define USE_DOUBLE_BUFFER 0
+#endif
+
+// ADAPTIVE_VISPLANES: Dynamic visplane limits
+// Start at 128 (vanilla), expand to 768 as needed
+// Source: Custom for SIGIL compatibility
+// Expected gain: Prevents crashes on complex maps
+#ifdef ADAPTIVE_VISPLANES
+#define USE_ADAPTIVE_VISPLANES 1
+#else
+#define USE_ADAPTIVE_VISPLANES 0
+#endif
+
+// RENDER_PREFETCH_ENABLED: Prefetch in render scaling loop
+// Prefetch source pixels during framebuffer scaling
+// Expected gain: Better cache utilization
+#ifdef RENDER_PREFETCH_ENABLED
+#define USE_RENDER_PREFETCH 1
+#else
+#define USE_RENDER_PREFETCH 0
+#endif
+
+// ============================================
+// AI THROTTLING PARAMETERS
+// ============================================
+
+#if USE_AI_THROTTLE
+// Distance thresholds in fixed-point units
+// 1024 fracunits = 32 map units
+#define AI_THROTTLE_DIST_NEAR   (1024 << FRACBITS)  // Always think
+#define AI_THROTTLE_DIST_MID    (2048 << FRACBITS)  // Think every 2 tics
+#define AI_THROTTLE_DIST_FAR    (4096 << FRACBITS)  // Think every 4 tics
+#endif
+
+// ============================================
+// VISPLANE PARAMETERS
+// ============================================
+
+#if USE_ADAPTIVE_VISPLANES
+#define MAXVISPLANES_POOL       768
+#define MAXVISPLANES_DEFAULT    128
+#define MAXVISPLANES_STEP1      256
+#define MAXVISPLANES_STEP2      512
+#define MAXVISPLANES_STEP3      768
+#define VISPLANE_EXPAND_THRESHOLD 0.9
+#define VISPLANE_MERGE_THRESHOLD  8
+#else
+#define MAXVISPLANES            512  // Increased from 128 for SIGIL
+#endif
+
+// ============================================
+// RUNTIME DETECTION
+// ============================================
+
+// Print which optimizations are compiled in
+static inline void PrintOptimizations(void) {
+    printf("Pager optimizations:\n");
+#if USE_INLINE_FIXED
+    printf("  [x] Inline fixed-point math\n");
+#else
+    printf("  [ ] Inline fixed-point math\n");
+#endif
+#if USE_AI_THROTTLE
+    printf("  [x] AI throttling\n");
+#else
+    printf("  [ ] AI throttling\n");
+#endif
+#if USE_THINKER_PREFETCH
+    printf("  [x] Thinker prefetch\n");
+#else
+    printf("  [ ] Thinker prefetch\n");
+#endif
+#if USE_DOUBLE_BUFFER
+    printf("  [x] Double buffering\n");
+#else
+    printf("  [ ] Double buffering\n");
+#endif
+#if USE_ADAPTIVE_VISPLANES
+    printf("  [x] Adaptive visplanes\n");
+#else
+    printf("  [ ] Adaptive visplanes\n");
+#endif
+}
+
+#endif // PAGER_OPTIMIZATIONS_H
diff --git a/doomgeneric/pager_opts.h b/doomgeneric/pager_opts.h
new file mode 100644
index 0000000..ae7185c
--- /dev/null
+++ b/doomgeneric/pager_opts.h
@@ -0,0 +1,67 @@
+// pager_opts.h - WiFi Pineapple Pager optimization macros
+//
+// Function attributes for hot code paths:
+//   HOT_FUNC      - More aggressive optimization, place in hot section
+//   FLATTEN_FUNC  - Inline all callees into this function
+//   FORCE_INLINE  - Always inline this function
+//   COLD_FUNC     - Rarely executed (error paths, init)
+//   PURE_FUNC     - No side effects, result depends only on arguments
+//   CONST_FUNC    - Like pure but doesn't read global memory
+//
+// These help the compiler make better decisions for MIPS 24KEc:
+// - HOT functions get more aggressive loop unrolling and scheduling
+// - FLATTEN reduces call overhead in tight loops
+// - Proper cold/hot separation improves instruction cache usage
+
+#ifndef PAGER_OPTS_H
+#define PAGER_OPTS_H
+
+#ifdef __GNUC__
+
+// Hot code path - more aggressive optimization
+#define HOT_FUNC __attribute__((hot))
+
+// Inline all callees into this function
+#define FLATTEN_FUNC __attribute__((flatten))
+
+// Always inline even at -O0
+#define FORCE_INLINE __attribute__((always_inline)) inline
+
+// Cold code path - rarely executed (error handling, init)
+#define COLD_FUNC __attribute__((cold))
+
+// Pure function - no side effects, depends only on args and global memory
+#define PURE_FUNC __attribute__((pure))
+
+// Const function - no side effects, depends ONLY on arguments
+#define CONST_FUNC __attribute__((const))
+
+// Never inline (for debugging or code size)
+#define NOINLINE_FUNC __attribute__((noinline))
+
+// Likely/unlikely branch hints
+#define LIKELY(x)   __builtin_expect(!!(x), 1)
+#define UNLIKELY(x) __builtin_expect(!!(x), 0)
+
+// Prefetch hints
+#define PREFETCH_READ(addr)  __builtin_prefetch((addr), 0, 3)
+#define PREFETCH_WRITE(addr) __builtin_prefetch((addr), 1, 3)
+
+#else
+
+// Non-GCC fallbacks
+#define HOT_FUNC
+#define FLATTEN_FUNC
+#define FORCE_INLINE inline
+#define COLD_FUNC
+#define PURE_FUNC
+#define CONST_FUNC
+#define NOINLINE_FUNC
+#define LIKELY(x)   (x)
+#define UNLIKELY(x) (x)
+#define PREFETCH_READ(addr)
+#define PREFETCH_WRITE(addr)
+
+#endif // __GNUC__
+
+#endif // PAGER_OPTS_H
diff --git a/doomgeneric/r_bsp.c b/doomgeneric/r_bsp.c
index 9a78812..2608601 100644
--- a/doomgeneric/r_bsp.c
+++ b/doomgeneric/r_bsp.c
@@ -43,7 +43,11 @@ line_t*		linedef;
 sector_t*	frontsector;
 sector_t*	backsector;
 
+#ifdef CACHE_ALIGN_ARRAYS
+drawseg_t	drawsegs[MAXDRAWSEGS] __attribute__((aligned(32)));
+#else
 drawseg_t	drawsegs[MAXDRAWSEGS];
+#endif
 drawseg_t*	ds_p;
 
 
diff --git a/doomgeneric/r_draw.c b/doomgeneric/r_draw.c
index 9271bcd..233fc83 100644
--- a/doomgeneric/r_draw.c
+++ b/doomgeneric/r_draw.c
@@ -29,6 +29,7 @@
 #include "w_wad.h"
 
 #include "r_local.h"
+#include "pager_opts.h"  // PAGER: function attributes for hot code
 
 // Needs access to LFB (guess what).
 #include "v_video.h"
@@ -99,7 +100,13 @@ int			dccount;
 // Thus a special case loop for very fast rendering can
 //  be used. It has also been used with Wolfenstein 3D.
 // 
-void R_DrawColumn (void) 
+//
+// PAGER OPTIMIZATION: Column prefetch
+// Prefetch texture data ahead in the inner loop to hide memory latency.
+// The texture is accessed via dc_source with frac as index.
+// Compile with: -DCOLUMN_PREFETCH_ENABLED
+//
+HOT_FUNC void R_DrawColumn (void) 
 { 
     int			count; 
     byte*		dest; 
@@ -109,7 +116,7 @@ void R_DrawColumn (void)
     count = dc_yh - dc_yl; 
 
     // Zero length, column does not exceed a pixel.
-    if (count < 0) 
+    if (UNLIKELY(count < 0)) 
 	return; 
 				 
 #ifdef RANGECHECK 
@@ -129,11 +136,21 @@ void R_DrawColumn (void)
     fracstep = dc_iscale; 
     frac = dc_texturemid + (dc_yl-centery)*fracstep; 
 
+#ifdef COLUMN_PREFETCH_ENABLED
+    // Prefetch first texture access
+    __builtin_prefetch(&dc_source[(frac>>FRACBITS)&127], 0, 1);
+#endif
+
     // Inner loop that does the actual texture mapping,
     //  e.g. a DDA-lile scaling.
     // This is as fast as it gets.
     do 
     {
+#ifdef COLUMN_PREFETCH_ENABLED
+	// Prefetch 8 pixels ahead in texture
+	if (count > 8)
+	    __builtin_prefetch(&dc_source[((frac + (fracstep << 3))>>FRACBITS)&127], 0, 1);
+#endif
 	// Re-map color indices from wall texture column
 	//  using a lighting/special effects LUT.
 	*dest = dc_colormap[dc_source[(frac>>FRACBITS)&127]];
@@ -205,7 +222,7 @@ void R_DrawColumn (void)
 #endif
 
 
-void R_DrawColumnLow (void) 
+HOT_FUNC void R_DrawColumnLow (void) 
 { 
     int			count; 
     byte*		dest; 
@@ -587,7 +604,7 @@ int			dscount;
 
 //
 // Draws the actual span.
-void R_DrawSpan (void) 
+HOT_FUNC void R_DrawSpan (void) 
 { 
     unsigned int position, step;
     byte *dest;
@@ -716,7 +733,7 @@ void R_DrawSpan (void)
 //
 // Again..
 //
-void R_DrawSpanLow (void)
+HOT_FUNC void R_DrawSpanLow (void)
 {
     unsigned int position, step;
     unsigned int xtemp, ytemp;
diff --git a/doomgeneric/r_main.c b/doomgeneric/r_main.c
index 22278fe..bb94c51 100644
--- a/doomgeneric/r_main.c
+++ b/doomgeneric/r_main.c
@@ -34,6 +34,7 @@
 
 #include "r_local.h"
 #include "r_sky.h"
+#include "pager_opts.h"  // PAGER: function attributes
 
 
 
@@ -860,7 +861,7 @@ void R_SetupFrame (player_t* player)
 //
 // R_RenderView
 //
-void R_RenderPlayerView (player_t* player)
+HOT_FUNC void R_RenderPlayerView (player_t* player)
 {	
     R_SetupFrame (player);
 
diff --git a/doomgeneric/r_plane.c b/doomgeneric/r_plane.c
index 56bab7e..7a2d0d9 100644
--- a/doomgeneric/r_plane.c
+++ b/doomgeneric/r_plane.c
@@ -41,9 +41,44 @@ planefunction_t		ceilingfunc;
 // opening
 //
 
-// Here comes the obnoxious "visplane".
-#define MAXVISPLANES	512  // Increased from 128 for complex maps like SIGIL
+//
+// PAGER OPTIMIZATION: Adaptive visplane limits
+//
+// When ADAPTIVE_VISPLANES is defined, we start at the vanilla Doom limit (128)
+// and automatically expand when needed, up to 768. This prevents crashes on
+// complex maps like SIGIL while maintaining vanilla behavior on simple maps.
+//
+// Without this flag, we use a fixed 512 limit (increased from vanilla 128).
+//
+// Source: Custom optimization for SIGIL compatibility
+// Expected gain: Crash prevention on complex maps
+//
+// Compile with: -DADAPTIVE_VISPLANES
+//
+#ifdef ADAPTIVE_VISPLANES
+
+#define MAXVISPLANES_POOL       768   // Static allocation size
+#define MAXVISPLANES_DEFAULT    128   // Start at vanilla Doom limit
+#define MAXVISPLANES_STEP1      256
+#define MAXVISPLANES_STEP2      512
+#define MAXVISPLANES_STEP3      768
+#define VISPLANE_EXPAND_THRESHOLD 0.9
+#define VISPLANE_MERGE_THRESHOLD  8
+
+visplane_t		visplanes[MAXVISPLANES_POOL];
+static int		visplane_limit = MAXVISPLANES_DEFAULT;
+static int		visplane_peak = 0;
+static int		visplane_merges = 0;
+static int		visplane_expansions = 0;
+
+#else
+
+// Fixed limit (increased from vanilla 128 for SIGIL)
+#define MAXVISPLANES	512
 visplane_t		visplanes[MAXVISPLANES];
+
+#endif
+
 visplane_t*		lastvisplane;
 visplane_t*		floorplane;
 visplane_t*		ceilingplane;
@@ -204,6 +239,26 @@ void R_ClearPlanes (void)
 
 
 
+#ifdef ADAPTIVE_VISPLANES
+// Auto-expand visplane limit when approaching threshold
+static void R_ExpandVisplaneLimit(void)
+{
+    int new_limit = visplane_limit;
+    
+    if (visplane_limit < MAXVISPLANES_STEP1)
+        new_limit = MAXVISPLANES_STEP1;
+    else if (visplane_limit < MAXVISPLANES_STEP2)
+        new_limit = MAXVISPLANES_STEP2;
+    else if (visplane_limit < MAXVISPLANES_STEP3)
+        new_limit = MAXVISPLANES_STEP3;
+    
+    if (new_limit > visplane_limit) {
+        visplane_limit = new_limit;
+        visplane_expansions++;
+    }
+}
+#endif
+
 //
 // R_FindPlane
 //
@@ -214,6 +269,11 @@ R_FindPlane
   int		lightlevel )
 {
     visplane_t*	check;
+#ifdef ADAPTIVE_VISPLANES
+    visplane_t* bestmatch = NULL;
+    int bestdiff = VISPLANE_MERGE_THRESHOLD + 1;
+    int current_count;
+#endif
 	
     if (picnum == skyflatnum)
     {
@@ -227,11 +287,63 @@ R_FindPlane
 	    && picnum == check->picnum
 	    && lightlevel == check->lightlevel)
 	{
+#ifdef ADAPTIVE_VISPLANES
+	    return check;
+#else
 	    break;
+#endif
 	}
     }
     
-			
+#ifdef ADAPTIVE_VISPLANES
+    // No exact match - need to allocate
+    current_count = lastvisplane - visplanes;
+    
+    // Auto-expand if approaching limit
+    if (current_count >= (int)(visplane_limit * VISPLANE_EXPAND_THRESHOLD))
+        R_ExpandVisplaneLimit();
+    
+    // At hard limit - graceful degradation
+    if (current_count >= visplane_limit && visplane_limit >= MAXVISPLANES_STEP3)
+    {
+        // Find closest match for merging
+        for (check=visplanes; check<lastvisplane; check++)
+        {
+            if (picnum == check->picnum)
+            {
+                int heightdiff = abs((height >> FRACBITS) - (check->height >> FRACBITS));
+                if (heightdiff < bestdiff)
+                {
+                    bestdiff = heightdiff;
+                    bestmatch = check;
+                }
+            }
+        }
+        
+        if (bestmatch && bestdiff <= VISPLANE_MERGE_THRESHOLD)
+        {
+            visplane_merges++;
+            return bestmatch;
+        }
+        
+        // Emergency: return any plane with same texture
+        for (check=visplanes; check<lastvisplane; check++)
+        {
+            if (picnum == check->picnum)
+            {
+                visplane_merges++;
+                return check;
+            }
+        }
+        visplane_merges++;
+        return visplanes;  // Last resort
+    }
+    
+    // Normal allocation
+    check = lastvisplane++;
+    if ((lastvisplane - visplanes) > visplane_peak)
+        visplane_peak = lastvisplane - visplanes;
+#else
     if (check < lastvisplane)
 	return check;
 		
@@ -239,6 +351,7 @@ R_FindPlane
 	I_Error ("R_FindPlane: no more visplanes");
 		
     lastvisplane++;
+#endif
 
     check->height = height;
     check->picnum = picnum;
@@ -266,6 +379,9 @@ R_CheckPlane
     int		unionl;
     int		unionh;
     int		x;
+#ifdef ADAPTIVE_VISPLANES
+    int		current_count;
+#endif
 	
     if (start < pl->minx)
     {
@@ -301,6 +417,23 @@ R_CheckPlane
 	// use the same one
 	return pl;		
     }
+
+#ifdef ADAPTIVE_VISPLANES
+    current_count = lastvisplane - visplanes;
+    
+    // Auto-expand if approaching limit
+    if (current_count >= (int)(visplane_limit * VISPLANE_EXPAND_THRESHOLD))
+        R_ExpandVisplaneLimit();
+    
+    // At hard limit: reuse existing plane
+    if (current_count >= visplane_limit && visplane_limit >= MAXVISPLANES_STEP3)
+    {
+        visplane_merges++;
+        pl->minx = unionl;
+        pl->maxx = unionh;
+        return pl;
+    }
+#endif
 	
     // make a new visplane
     lastvisplane->height = pl->height;
@@ -308,6 +441,10 @@ R_CheckPlane
     lastvisplane->lightlevel = pl->lightlevel;
     
     pl = lastvisplane++;
+#ifdef ADAPTIVE_VISPLANES
+    if ((lastvisplane - visplanes) > visplane_peak)
+        visplane_peak = lastvisplane - visplanes;
+#endif
     pl->minx = start;
     pl->maxx = stop;
 
@@ -371,9 +508,15 @@ void R_DrawPlanes (void)
 	I_Error ("R_DrawPlanes: drawsegs overflow (%i)",
 		 ds_p - drawsegs);
     
+#ifdef ADAPTIVE_VISPLANES
+    if (lastvisplane - visplanes > MAXVISPLANES_POOL)
+	I_Error ("R_DrawPlanes: visplane overflow (%i)",
+		 lastvisplane - visplanes);
+#else
     if (lastvisplane - visplanes > MAXVISPLANES)
 	I_Error ("R_DrawPlanes: visplane overflow (%i)",
 		 lastvisplane - visplanes);
+#endif
     
     if (lastopening - openings > MAXOPENINGS)
 	I_Error ("R_DrawPlanes: opening overflow (%i)",
diff --git a/doomgeneric/r_things.c b/doomgeneric/r_things.c
index 74e7369..d207de8 100644
--- a/doomgeneric/r_things.c
+++ b/doomgeneric/r_things.c
@@ -278,7 +278,12 @@ void R_InitSpriteDefs (char** namelist)
 //
 // GAME FUNCTIONS
 //
+#ifdef CACHE_ALIGN_ARRAYS
+// PAGER OPTIMIZATION: Cache-align hot arrays for MIPS 24KEc (32-byte cache lines)
+vissprite_t	vissprites[MAXVISSPRITES] __attribute__((aligned(32)));
+#else
 vissprite_t	vissprites[MAXVISSPRITES];
+#endif
 vissprite_t*	vissprite_p;
 int		newvissprite;
 
