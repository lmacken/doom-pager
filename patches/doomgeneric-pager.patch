From 9a22f2ebde6a15a74281c4b857b4ee8c29a447c9 Mon Sep 17 00:00:00 2001
From: Luke Macken <luke@farmgpu.com>
Date: Sat, 3 Jan 2026 20:04:56 -0700
Subject: [PATCH 1/7] Add WiFi Pineapple Pager support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add MIPS cross-compilation support via OpenWrt SDK (Makefile.mipsel)
- Add QEMU wrapper for running x86-64 toolchain on ARM64 host
- Support 16-bit RGB565 framebuffer with 90° CCW rotation
- Add WiFi Pineapple Pager button mappings (BTN_SOUTH=fire, BTN_EAST=enter)
- Use write() instead of mmap for stable fbtft/SPI display output
- Add KD_GRAPHICS mode for exclusive framebuffer access
- Add signal handlers for clean exit and text mode restoration

Tested on WiFi Pineapple Pager (MIPS MT7628, 222x480 ST7796U display)
---
 doomgeneric/Makefile.mipsel       |  58 +++++++++++
 doomgeneric/doomgeneric_linuxvt.c | 153 ++++++++++++++++++++++++++----
 doomgeneric/qemu-gcc-wrapper.sh   |  13 +++
 3 files changed, 205 insertions(+), 19 deletions(-)
 create mode 100644 doomgeneric/Makefile.mipsel
 create mode 100755 doomgeneric/qemu-gcc-wrapper.sh

diff --git a/doomgeneric/Makefile.mipsel b/doomgeneric/Makefile.mipsel
new file mode 100644
index 0000000..8e73649
--- /dev/null
+++ b/doomgeneric/Makefile.mipsel
@@ -0,0 +1,58 @@
+################################################################
+#
+# Cross-compilation Makefile for MIPS (mipsel-linux-gnu)
+# For WiFi Pineapple Pager
+#
+
+ifeq ($(V),1)
+	VB=''
+else
+	VB=@
+endif
+
+# OpenWrt SDK musl-based cross-compiler for mipsel_24kc
+# Using QEMU wrapper to run x86-64 SDK on ARM64 host
+CC=$(shell pwd)/qemu-gcc-wrapper.sh
+CROSS_COMPILE=$(shell pwd)/qemu-gcc-wrapper.sh
+# OpenWrt SDK already configured for mipsel_24kc with musl
+CFLAGS+=-Os -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
+LDFLAGS+=-static
+# Target MIPS 24Kc architecture - OpenWrt SDK already configured for mipsel_24kc
+CFLAGS+=-Os -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
+LDFLAGS+=-static
+LIBS+=-lm -lc
+
+# subdirectory for objects
+OBJDIR=build
+OUTPUT=doomgeneric
+
+SRC_DOOM = dummy.o am_map.o doomdef.o doomstat.o dstrings.o d_event.o d_items.o d_iwad.o d_loop.o d_main.o d_mode.o d_net.o f_finale.o f_wipe.o g_game.o hu_lib.o hu_stuff.o info.o i_cdmus.o i_endoom.o i_joystick.o i_scale.o i_sound.o i_system.o i_timer.o memio.o m_argv.o m_bbox.o m_cheat.o m_config.o m_controls.o m_fixed.o m_menu.o m_misc.o m_random.o p_ceilng.o p_doors.o p_enemy.o p_floor.o p_inter.o p_lights.o p_map.o p_maputl.o p_mobj.o p_plats.o p_pspr.o p_saveg.o p_setup.o p_sight.o p_spec.o p_switch.o p_telept.o p_tick.o p_user.o r_bsp.o r_data.o r_draw.o r_main.o r_plane.o r_segs.o r_sky.o r_things.o sha1.o sounds.o statdump.o st_lib.o st_stuff.o s_sound.o tables.o v_video.o wi_stuff.o w_checksum.o w_file.o w_main.o w_wad.o z_zone.o w_file_stdc.o i_input.o i_video.o doomgeneric.o doomgeneric_linuxvt.o mus2mid.o
+OBJS += $(addprefix $(OBJDIR)/, $(SRC_DOOM))
+
+all:	 $(OUTPUT)
+
+clean:
+	rm -rf $(OBJDIR)
+	rm -f $(OUTPUT)
+	rm -f $(OUTPUT).gdb
+	rm -f $(OUTPUT).map
+
+$(OUTPUT):	$(OBJS)
+	@echo [Linking $@]
+	$(VB)$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) \
+	-o $(OUTPUT) $(LIBS)
+	@echo [Size]
+	-@size $(OUTPUT) 2>/dev/null || true
+
+$(OBJS): | $(OBJDIR)
+
+$(OBJDIR):
+	mkdir -p $(OBJDIR)
+
+$(OBJDIR)/%.o:	%.c
+	@echo [Compiling $<]
+	$(VB)$(CC) $(CFLAGS) -c $< -o $@
+
+print:
+	@echo OBJS: $(OBJS)
+
diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index ed94dd9..3e910ff 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -46,6 +46,7 @@
 
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <errno.h>
@@ -58,6 +59,9 @@
 #include <linux/input.h>
 #include <linux/input-event-codes.h>
 #include <linux/fb.h>
+#include <linux/kd.h>
+#include <linux/vt.h>
+#include <signal.h>
 
 #include <stdbool.h>
 
@@ -74,8 +78,24 @@ static struct timeval startTime;
 
 // framebuffer stuff 
 static uint8_t *fbPtr;
+static uint16_t *renderBuffer = NULL;  // Local render buffer for 16-bit mode
+static unsigned int renderBufferSize = 0;
 static int fbFd;
+static int ttyFd = -1;  // TTY for graphics mode switching
 static unsigned int fbWidth, fbHeight, fbStride, fbBytesPerPixel, fbOffsetX, fbOffsetY;
+static int fbIs16Bit = 0; // 1 if framebuffer is 16-bit RGB565
+
+// Cleanup function for signal handling
+static void cleanup_and_exit(int sig) {
+	// Restore text mode if we switched to graphics mode
+	if (ttyFd >= 0) {
+		ioctl(ttyFd, KDSETMODE, KD_TEXT);
+		close(ttyFd);
+	}
+	if (renderBuffer) free(renderBuffer);
+	if (fbFd >= 0) close(fbFd);
+	_exit(sig ? 128 + sig : 0);
+}
 
 // input stuff
 static int numInputFds = 0;
@@ -197,6 +217,14 @@ static unsigned char convertToDoomKey(unsigned int key){
 			key = DOOM_KEY_TAB;
 			break;
 
+		// WiFi Pineapple Pager button mappings
+		case 0x130:  // BTN_SOUTH (304) - red button
+			key = KEY_FIRE;
+			break;
+		case 0x131:  // BTN_EAST (305) - green button
+			key = DOOM_KEY_ENTER;
+			break;
+
 		// sadly, yes, we need to handle every single alphanumeric
 		// key here, since evdev doesn't spit out keys in anything
 		// remotely resembling ASCII.....
@@ -273,7 +301,7 @@ static unsigned char convertToDoomKey(unsigned int key){
 	return key;
 }
 
-static void addKeyToQueue(int pressed, unsigned char keyCode) {
+static void addKeyToQueue(int pressed, unsigned int keyCode) {
 	if ((keyCode == KEY_LEFTSHIFT || keyCode == KEY_RIGHTSHIFT) &&
 		(pressed == 1 || pressed == 0))
 		shiftPressed = pressed;
@@ -353,10 +381,17 @@ static int isKeyboard(const char *devPath) {
 		return 0;
 	}
 
+	/* Accept full keyboards OR any device with button keys (for GPIO buttons) */
 	if (TEST_KEY(KEY_A) && TEST_KEY(KEY_ENTER)) {
 		close(fd);
 		return 1;  /* looks like a keyboard */
 	}
+	
+	/* Also accept devices with BTN_SOUTH/BTN_EAST (Pineapple Pager buttons) */
+	if (TEST_KEY(0x130) || TEST_KEY(0x131)) {
+		close(fd);
+		return 1;  /* has GPIO buttons */
+	}
 
 	close(fd);
 	return 0;
@@ -409,6 +444,30 @@ void DG_Init() {
 	struct fb_var_screeninfo info;
 	struct fb_fix_screeninfo finfo;
 
+	// Set up signal handlers for clean exit
+	signal(SIGINT, cleanup_and_exit);
+	signal(SIGTERM, cleanup_and_exit);
+	signal(SIGSEGV, cleanup_and_exit);
+
+	//
+	// Try to get exclusive graphics mode access
+	// This prevents the console/other apps from interfering
+	//
+	ttyFd = open("/dev/tty0", O_RDWR);
+	if (ttyFd < 0)
+		ttyFd = open("/dev/tty", O_RDWR);
+	if (ttyFd < 0)
+		ttyFd = open("/dev/console", O_RDWR);
+	
+	if (ttyFd >= 0) {
+		// Switch to graphics mode - prevents console from drawing
+		if (ioctl(ttyFd, KDSETMODE, KD_GRAPHICS) == 0) {
+			printf("Switched to graphics mode\n");
+		} else {
+			printf("Warning: Could not switch to graphics mode\n");
+		}
+	}
+
 	//
 	// set up the framebuffer
 	//
@@ -434,19 +493,42 @@ void DG_Init() {
 	fbWidth = info.xres;
 	fbHeight = info.yres;
 	fbBytesPerPixel = info.bits_per_pixel / 8;
+	
+	// Detect 16-bit RGB565 framebuffer
+	if (info.bits_per_pixel == 16) {
+		fbIs16Bit = 1;
+		printf("Framebuffer: %dx%d, 16-bit RGB565\n", fbWidth, fbHeight);
+		
+		// Use write() for SPI displays - mmap causes glitches with fbtft
+		renderBufferSize = fbWidth * fbHeight * sizeof(uint16_t);
+		renderBuffer = (uint16_t *)malloc(renderBufferSize);
+		if (!renderBuffer)
+			I_Error("Failed to allocate render buffer");
+		memset(renderBuffer, 0, renderBufferSize);
+		
+		// Clear the display
+		lseek(fbFd, 0, SEEK_SET);
+		write(fbFd, renderBuffer, renderBufferSize);
+		
+		fbPtr = NULL;
+		fbOffsetX = 0;
+		fbOffsetY = 0;
+	} else {
+		printf("Framebuffer: %dx%d, %d-bit\n", fbWidth, fbHeight, info.bits_per_pixel);
+		
+		// For 32-bit displays, use mmap as normal
+		fbOffsetX = ((fbWidth - DOOMGENERIC_RESX) / 2) * fbBytesPerPixel;
+		fbOffsetY = ((fbHeight - DOOMGENERIC_RESY) / 2) * fbStride;
 
-	// to center the image on screen
-	fbOffsetX = ((fbWidth - DOOMGENERIC_RESX) / 2) * fbBytesPerPixel;
-	fbOffsetY = ((fbHeight - DOOMGENERIC_RESY) / 2) * fbStride;
-
-	fbPtr = mmap(NULL, fbStride * fbHeight, PROT_READ | PROT_WRITE,
-			MAP_SHARED, fbFd, 0);
+		fbPtr = mmap(NULL, fbStride * fbHeight, PROT_READ | PROT_WRITE,
+				MAP_SHARED, fbFd, 0);
 
-	if (!fbPtr)
-		I_Error("Failed to mmap /dev/fb0: %s", strerror(errno));
+		if (!fbPtr)
+			I_Error("Failed to mmap /dev/fb0: %s", strerror(errno));
 
-	// clear the screen
-	memset(fbPtr, 0, fbStride * fbHeight);
+		// clear the screen
+		memset(fbPtr, 0, fbStride * fbHeight);
+	}
 
 	//
 	// set up input
@@ -460,16 +542,49 @@ void DG_Init() {
 	gettimeofday(&startTime, NULL);
 }
 
+// Convert 32-bit ARGB to 16-bit RGB565
+static inline uint16_t rgb32_to_rgb565(uint32_t pixel) {
+	uint8_t r = (pixel >> 16) & 0xFF;
+	uint8_t g = (pixel >> 8) & 0xFF;
+	uint8_t b = pixel & 0xFF;
+	return ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
+}
+
 void DG_DrawFrame() {
-	// we need to do it line-by-line like this to account for the
-	// fact that the system framebuffer resolution is very likely
-	// larger than the doomgeneric render resolution.
-	for (int line = 0; line < DOOMGENERIC_RESY; line++) {
-		memcpy(
-			(void *)((uintptr_t)(fbPtr) + (fbStride * line) + fbOffsetY + fbOffsetX),
+	if (fbIs16Bit) {
+		// 16-bit RGB565 with 90° CCW rotation for portrait display
+		// Doom is 640x400, display is 222x480
+		// After rotation: Doom height (400) -> display width (222)
+		// Scale to fill width: scale = 222/400 = 0.555
+		// Output height = 640 * 0.555 = 355
+		
+		unsigned int outW = fbWidth;  // 222
+		unsigned int outH = (DOOMGENERIC_RESX * fbWidth) / DOOMGENERIC_RESY;  // 355
+		if (outH > fbHeight) outH = fbHeight;
+		unsigned int offY = (fbHeight - outH) / 2;  // Center vertically
+		
+		// Render to buffer then write (stable with fbtft)
+		for (unsigned int y = 0; y < outH; y++) {
+			uint16_t *dst = renderBuffer + (y + offY) * fbWidth;
+			unsigned int srcX = (y * DOOMGENERIC_RESX) / outH;
+			
+			for (unsigned int x = 0; x < outW; x++) {
+				unsigned int srcY = ((outW - 1 - x) * DOOMGENERIC_RESY) / outW;
+				uint32_t pixel = ((uint32_t *)DG_ScreenBuffer)[srcY * DOOMGENERIC_RESX + srcX];
+				dst[x] = rgb32_to_rgb565(pixel);
+			}
+		}
+		lseek(fbFd, 0, SEEK_SET);
+		write(fbFd, renderBuffer, renderBufferSize);
+	} else {
+		// Original 32-bit mmap path
+		for (int line = 0; line < DOOMGENERIC_RESY; line++) {
+			memcpy(
+				(void *)((uintptr_t)(fbPtr) + (fbStride * line) + fbOffsetY + fbOffsetX),
 				(void *)(((uintptr_t)DG_ScreenBuffer) + (DOOMGENERIC_RESX * line * fbBytesPerPixel)),
-			 (fbBytesPerPixel * DOOMGENERIC_RESX)
-		);
+				(fbBytesPerPixel * DOOMGENERIC_RESX)
+			);
+		}
 	}
 
 	checkKeys();
diff --git a/doomgeneric/qemu-gcc-wrapper.sh b/doomgeneric/qemu-gcc-wrapper.sh
new file mode 100755
index 0000000..58a10b4
--- /dev/null
+++ b/doomgeneric/qemu-gcc-wrapper.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+# Wrapper to run OpenWrt SDK gcc through QEMU
+
+OPENWRT_SDK="/home/l/code/pineapple/doom/openwrt-sdk-22.03.5-ramips-mt76x8_gcc-11.2.0_musl.Linux-x86_64"
+TOOLCHAIN_DIR="$OPENWRT_SDK/staging_dir/toolchain-mipsel_24kc_gcc-11.2.0_musl"
+HOST_DIR="$OPENWRT_SDK/staging_dir/host"
+
+export STAGING_DIR="$OPENWRT_SDK/staging_dir"
+export PATH="$TOOLCHAIN_DIR/bin:$PATH"
+
+# Use QEMU to run the x86-64 compiler binary directly with proper library paths
+exec qemu-x86_64 -L "$HOST_DIR" -E LD_LIBRARY_PATH="$HOST_DIR/lib" "$TOOLCHAIN_DIR/bin/.mipsel-openwrt-linux-musl-gcc.bin" "$@"
+
-- 
2.48.1


From 03aeadf8a2511abaf93fa552e4b7acd3296b789c Mon Sep 17 00:00:00 2001
From: Luke Macken <luke@farmgpu.com>
Date: Sat, 3 Jan 2026 20:14:21 -0700
Subject: [PATCH 2/7] Add Red+Green button combo for menu, skip quit
 confirmation

- Press Red+Green buttons together to open ESC menu
- M_QuitDOOM now quits immediately without Y/N confirmation
- Better UX for embedded devices without full keyboard
---
 doomgeneric/doomgeneric_linuxvt.c | 19 +++++++++++++++++++
 doomgeneric/m_menu.c              |  6 ++----
 2 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index 3e910ff..b8aec58 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -107,6 +107,10 @@ static unsigned short s_KeyQueue[KEYQUEUE_SIZE];
 static unsigned int s_KeyQueueWriteIndex = 0;
 static unsigned int s_KeyQueueReadIndex = 0;
 
+// Track button states for combo detection (both buttons = ESC/menu)
+static int redButtonPressed = 0;   // BTN_SOUTH (0x130)
+static int greenButtonPressed = 0; // BTN_EAST (0x131)
+
 // XXX: HACK
 // Linux's evdev system doesn't make it feasible to just use
 // tolower(key) like the existing conversions did, so we
@@ -306,6 +310,21 @@ static void addKeyToQueue(int pressed, unsigned int keyCode) {
 		(pressed == 1 || pressed == 0))
 		shiftPressed = pressed;
 
+	// Track button states for combo detection
+	if (keyCode == 0x130) {  // Red button
+		redButtonPressed = pressed;
+	} else if (keyCode == 0x131) {  // Green button
+		greenButtonPressed = pressed;
+	}
+	
+	// Both buttons pressed together = ESC (main menu)
+	if (redButtonPressed && greenButtonPressed && pressed) {
+		unsigned short escData = (1 << 8) | KEY_ESCAPE;
+		s_KeyQueue[s_KeyQueueWriteIndex] = escData;
+		s_KeyQueueWriteIndex++;
+		s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
+		return;  // Don't also send the individual button
+	}
 		
 	unsigned char key = convertToDoomKey(keyCode);
 	if (key == 0xFF) // unknown, don't process it
diff --git a/doomgeneric/m_menu.c b/doomgeneric/m_menu.c
index 6df9655..4feb72c 100644
--- a/doomgeneric/m_menu.c
+++ b/doomgeneric/m_menu.c
@@ -1167,10 +1167,8 @@ static char *M_SelectEndMessage(void)
 
 void M_QuitDOOM(int choice)
 {
-    DEH_snprintf(endstring, sizeof(endstring), "%s\n\n" DOSY,
-                 DEH_String(M_SelectEndMessage()));
-
-    M_StartMessage(endstring,M_QuitResponse,true);
+    // Skip confirmation on embedded devices (no keyboard for 'y')
+    I_Quit();
 }
 
 
-- 
2.48.1


From 5c64d89ef6ca8073d2c5fcf8c61c8efb70b1bec1 Mon Sep 17 00:00:00 2001
From: Luke Macken <luke@farmgpu.com>
Date: Sat, 3 Jan 2026 22:03:29 -0700
Subject: [PATCH 3/7] Performance optimizations for smoother rendering

- Reduce internal resolution to 320x200 (4x fewer pixels to render)
- Enable -O3 compiler optimization for maximum speed
- Precompute scaling lookup tables at init (avoid per-pixel division)
- Inline RGB565 conversion (avoid function call overhead)

Results in significantly smoother gameplay on WiFi Pineapple Pager.
---
 doomgeneric/Makefile.mipsel       |  9 +++---
 doomgeneric/doomgeneric_linuxvt.c | 54 ++++++++++++++++++++-----------
 2 files changed, 40 insertions(+), 23 deletions(-)

diff --git a/doomgeneric/Makefile.mipsel b/doomgeneric/Makefile.mipsel
index 8e73649..b3962b8 100644
--- a/doomgeneric/Makefile.mipsel
+++ b/doomgeneric/Makefile.mipsel
@@ -14,11 +14,10 @@ endif
 # Using QEMU wrapper to run x86-64 SDK on ARM64 host
 CC=$(shell pwd)/qemu-gcc-wrapper.sh
 CROSS_COMPILE=$(shell pwd)/qemu-gcc-wrapper.sh
-# OpenWrt SDK already configured for mipsel_24kc with musl
-CFLAGS+=-Os -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
-LDFLAGS+=-static
-# Target MIPS 24Kc architecture - OpenWrt SDK already configured for mipsel_24kc
-CFLAGS+=-Os -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
+# Render at native 320x200 (faster than 640x400)
+CFLAGS+=-DDOOMGENERIC_RESX=320 -DDOOMGENERIC_RESY=200
+# Optimize for speed, enable MIPS-specific opts
+CFLAGS+=-O3 -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
 LDFLAGS+=-static
 LIBS+=-lm -lc
 
diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index b8aec58..8fcc003 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -85,6 +85,13 @@ static int ttyFd = -1;  // TTY for graphics mode switching
 static unsigned int fbWidth, fbHeight, fbStride, fbBytesPerPixel, fbOffsetX, fbOffsetY;
 static int fbIs16Bit = 0; // 1 if framebuffer is 16-bit RGB565
 
+// Precomputed lookup tables for scaling (avoids per-pixel division)
+static unsigned int *srcXLookup = NULL;  // For each dest Y, source X
+static unsigned int *srcYLookup = NULL;  // For each dest X, source Y
+static unsigned int scaledOutW = 0;
+static unsigned int scaledOutH = 0;
+static unsigned int scaledOffY = 0;
+
 // Cleanup function for signal handling
 static void cleanup_and_exit(int sig) {
 	// Restore text mode if we switched to graphics mode
@@ -532,6 +539,25 @@ void DG_Init() {
 		fbPtr = NULL;
 		fbOffsetX = 0;
 		fbOffsetY = 0;
+		
+		// Precompute scaling lookup tables (avoid per-pixel division)
+		scaledOutW = fbWidth;  // 222
+		scaledOutH = (DOOMGENERIC_RESX * fbWidth) / DOOMGENERIC_RESY;
+		if (scaledOutH > fbHeight) scaledOutH = fbHeight;
+		scaledOffY = (fbHeight - scaledOutH) / 2;
+		
+		srcXLookup = (unsigned int *)malloc(scaledOutH * sizeof(unsigned int));
+		srcYLookup = (unsigned int *)malloc(scaledOutW * sizeof(unsigned int));
+		
+		for (unsigned int y = 0; y < scaledOutH; y++) {
+			srcXLookup[y] = (y * DOOMGENERIC_RESX) / scaledOutH;
+		}
+		for (unsigned int x = 0; x < scaledOutW; x++) {
+			srcYLookup[x] = ((scaledOutW - 1 - x) * DOOMGENERIC_RESY) / scaledOutW;
+		}
+		
+		printf("Scaling: %dx%d -> %dx%d (lookup tables ready)\n", 
+		       DOOMGENERIC_RESX, DOOMGENERIC_RESY, scaledOutW, scaledOutH);
 	} else {
 		printf("Framebuffer: %dx%d, %d-bit\n", fbWidth, fbHeight, info.bits_per_pixel);
 		
@@ -571,26 +597,18 @@ static inline uint16_t rgb32_to_rgb565(uint32_t pixel) {
 
 void DG_DrawFrame() {
 	if (fbIs16Bit) {
-		// 16-bit RGB565 with 90° CCW rotation for portrait display
-		// Doom is 640x400, display is 222x480
-		// After rotation: Doom height (400) -> display width (222)
-		// Scale to fill width: scale = 222/400 = 0.555
-		// Output height = 640 * 0.555 = 355
-		
-		unsigned int outW = fbWidth;  // 222
-		unsigned int outH = (DOOMGENERIC_RESX * fbWidth) / DOOMGENERIC_RESY;  // 355
-		if (outH > fbHeight) outH = fbHeight;
-		unsigned int offY = (fbHeight - outH) / 2;  // Center vertically
+		// Optimized 16-bit RGB565 with 90° CCW rotation
+		// Uses precomputed lookup tables to avoid per-pixel division
+		uint32_t *srcBuf = (uint32_t *)DG_ScreenBuffer;
 		
-		// Render to buffer then write (stable with fbtft)
-		for (unsigned int y = 0; y < outH; y++) {
-			uint16_t *dst = renderBuffer + (y + offY) * fbWidth;
-			unsigned int srcX = (y * DOOMGENERIC_RESX) / outH;
+		for (unsigned int y = 0; y < scaledOutH; y++) {
+			uint16_t *dst = renderBuffer + (y + scaledOffY) * fbWidth;
+			unsigned int srcX = srcXLookup[y];
 			
-			for (unsigned int x = 0; x < outW; x++) {
-				unsigned int srcY = ((outW - 1 - x) * DOOMGENERIC_RESY) / outW;
-				uint32_t pixel = ((uint32_t *)DG_ScreenBuffer)[srcY * DOOMGENERIC_RESX + srcX];
-				dst[x] = rgb32_to_rgb565(pixel);
+			for (unsigned int x = 0; x < scaledOutW; x++) {
+				uint32_t pixel = srcBuf[srcYLookup[x] * DOOMGENERIC_RESX + srcX];
+				// Inline RGB565 conversion (avoid function call overhead)
+				dst[x] = ((pixel >> 8) & 0xF800) | ((pixel >> 5) & 0x07E0) | ((pixel >> 3) & 0x001F);
 			}
 		}
 		lseek(fbFd, 0, SEEK_SET);
-- 
2.48.1


From 68cde108ce41d0397c35c3d09cb366d05b084d3f Mon Sep 17 00:00:00 2001
From: Luke Macken <luke@farmgpu.com>
Date: Sat, 3 Jan 2026 22:58:01 -0700
Subject: [PATCH 4/7] Add aspect ratio correction for title screens and FOV
 adjustment

- Widen FOV from 2048 to 2765 to compensate for display stretch
- Add aspect-correct rendering for title screens/menus with black bars
- Gameplay fills entire 222x480 display with FOV compensation
- Title screen centered with ~62px black bars on each side
- Detect gamestate to switch between aspect modes
---
 doomgeneric/Makefile.mipsel       |  5 +-
 doomgeneric/doomgeneric_linuxvt.c | 96 ++++++++++++++++++++++++++-----
 2 files changed, 86 insertions(+), 15 deletions(-)

diff --git a/doomgeneric/Makefile.mipsel b/doomgeneric/Makefile.mipsel
index b3962b8..970020d 100644
--- a/doomgeneric/Makefile.mipsel
+++ b/doomgeneric/Makefile.mipsel
@@ -14,8 +14,11 @@ endif
 # Using QEMU wrapper to run x86-64 SDK on ARM64 host
 CC=$(shell pwd)/qemu-gcc-wrapper.sh
 CROSS_COMPILE=$(shell pwd)/qemu-gcc-wrapper.sh
-# Render at native 320x200 (faster than 640x400)
+# Keep Doom at 320x200 internally, we scale in output code
 CFLAGS+=-DDOOMGENERIC_RESX=320 -DDOOMGENERIC_RESY=200
+# Widen FOV to compensate for aspect ratio stretch (480/320)/(222/200) = 1.35x
+# Original FOV is 2048, adjusted: 2048 * 1.35 = 2765
+CFLAGS+=-DFIELDOFVIEW=2765
 # Optimize for speed, enable MIPS-specific opts
 CFLAGS+=-O3 -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
 LDFLAGS+=-static
diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index 8fcc003..7e93b5d 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -6,6 +6,8 @@
 #include "m_argv.h"
 #include "doomgeneric.h"
 #include "i_system.h"
+#include "doomdef.h"   // For GS_LEVEL constant
+#include "doomstat.h"  // For gamestate variable
 
 // XXX: HACK
 // Linux's input-event-codes.h and doomkeys.h have many collisions.
@@ -86,12 +88,20 @@ static unsigned int fbWidth, fbHeight, fbStride, fbBytesPerPixel, fbOffsetX, fbO
 static int fbIs16Bit = 0; // 1 if framebuffer is 16-bit RGB565
 
 // Precomputed lookup tables for scaling (avoids per-pixel division)
+// Full-screen stretched (for gameplay with FOV correction)
 static unsigned int *srcXLookup = NULL;  // For each dest Y, source X
 static unsigned int *srcYLookup = NULL;  // For each dest X, source Y
 static unsigned int scaledOutW = 0;
 static unsigned int scaledOutH = 0;
 static unsigned int scaledOffY = 0;
 
+// Aspect-correct (for title screens/menus - uses black bars)
+static unsigned int *srcXLookupAspect = NULL;
+static unsigned int *srcYLookupAspect = NULL;
+static unsigned int aspectOutW = 0;
+static unsigned int aspectOutH = 0;
+static unsigned int aspectOffY = 0;  // Vertical offset for centering (in display rows)
+
 // Cleanup function for signal handling
 static void cleanup_and_exit(int sig) {
 	// Restore text mode if we switched to graphics mode
@@ -100,6 +110,10 @@ static void cleanup_and_exit(int sig) {
 		close(ttyFd);
 	}
 	if (renderBuffer) free(renderBuffer);
+	if (srcXLookup) free(srcXLookup);
+	if (srcYLookup) free(srcYLookup);
+	if (srcXLookupAspect) free(srcXLookupAspect);
+	if (srcYLookupAspect) free(srcYLookupAspect);
 	if (fbFd >= 0) close(fbFd);
 	_exit(sig ? 128 + sig : 0);
 }
@@ -540,24 +554,59 @@ void DG_Init() {
 		fbOffsetX = 0;
 		fbOffsetY = 0;
 		
-		// Precompute scaling lookup tables (avoid per-pixel division)
-		scaledOutW = fbWidth;  // 222
-		scaledOutH = (DOOMGENERIC_RESX * fbWidth) / DOOMGENERIC_RESY;
-		if (scaledOutH > fbHeight) scaledOutH = fbHeight;
-		scaledOffY = (fbHeight - scaledOutH) / 2;
+		// Fill entire 222x480 display with 320x200 Doom + 90° CCW rotation
+		// After rotation: Doom width (320) -> display height (480), Doom height (200) -> display width (222)
+		// Scale factors: 480/320 = 1.5 for height, 222/200 = 1.11 for width
+		scaledOutW = fbWidth;   // 222 (fills display width)
+		scaledOutH = fbHeight;  // 480 (fills display height)
+		scaledOffY = 0;  // No offset, fills entire screen
 		
+		// Precompute lookup tables for STRETCHED scaling + rotation (gameplay)
 		srcXLookup = (unsigned int *)malloc(scaledOutH * sizeof(unsigned int));
 		srcYLookup = (unsigned int *)malloc(scaledOutW * sizeof(unsigned int));
 		
+		// For each display row (y), compute which Doom column (X) to sample
+		// Display Y maps to Doom X: srcX = y * DoomWidth / displayHeight
 		for (unsigned int y = 0; y < scaledOutH; y++) {
 			srcXLookup[y] = (y * DOOMGENERIC_RESX) / scaledOutH;
+			if (srcXLookup[y] >= DOOMGENERIC_RESX) srcXLookup[y] = DOOMGENERIC_RESX - 1;
 		}
+		// For each display col (x), compute which Doom row (Y) to sample (flipped for CCW)
+		// Display X maps to Doom Y (inverted): srcY = (width-1-x) * DoomHeight / displayWidth
 		for (unsigned int x = 0; x < scaledOutW; x++) {
 			srcYLookup[x] = ((scaledOutW - 1 - x) * DOOMGENERIC_RESY) / scaledOutW;
+			if (srcYLookup[x] >= DOOMGENERIC_RESY) srcYLookup[x] = DOOMGENERIC_RESY - 1;
 		}
 		
-		printf("Scaling: %dx%d -> %dx%d (lookup tables ready)\n", 
-		       DOOMGENERIC_RESX, DOOMGENERIC_RESY, scaledOutW, scaledOutH);
+		printf("Full-screen: Doom %dx%d -> Display %dx%d (scaled + rotated)\n", 
+		       DOOMGENERIC_RESX, DOOMGENERIC_RESY, fbWidth, fbHeight);
+		
+		// Precompute lookup tables for ASPECT-CORRECT scaling (title screens)
+		// Display: 222 wide x 480 tall. After 90° CCW rotation from Doom's POV: 480 wide x 222 tall
+		// Doom is 320x200 (1.6:1 aspect). To maintain aspect with 222 vertical pixels:
+		// Scaled width = 222 * (320/200) = 222 * 1.6 = 355 display rows
+		// Black bars: (480 - 355) / 2 = 62 pixels on each side
+		aspectOutW = fbWidth;  // 222 - use full display columns (becomes Doom's vertical)
+		aspectOutH = (aspectOutW * DOOMGENERIC_RESX) / DOOMGENERIC_RESY;  // 222 * 320 / 200 = 355
+		if (aspectOutH > fbHeight) aspectOutH = fbHeight;
+		aspectOffY = (fbHeight - aspectOutH) / 2;  // Center vertically: (480 - 355) / 2 = 62
+		
+		srcXLookupAspect = (unsigned int *)malloc(aspectOutH * sizeof(unsigned int));
+		srcYLookupAspect = (unsigned int *)malloc(aspectOutW * sizeof(unsigned int));
+		
+		// For each output row in the aspect-correct region, which Doom X to sample
+		for (unsigned int y = 0; y < aspectOutH; y++) {
+			srcXLookupAspect[y] = (y * DOOMGENERIC_RESX) / aspectOutH;
+			if (srcXLookupAspect[y] >= DOOMGENERIC_RESX) srcXLookupAspect[y] = DOOMGENERIC_RESX - 1;
+		}
+		// For each output column, which Doom Y to sample (inverted for CCW rotation)
+		for (unsigned int x = 0; x < aspectOutW; x++) {
+			srcYLookupAspect[x] = ((aspectOutW - 1 - x) * DOOMGENERIC_RESY) / aspectOutW;
+			if (srcYLookupAspect[x] >= DOOMGENERIC_RESY) srcYLookupAspect[x] = DOOMGENERIC_RESY - 1;
+		}
+		
+		printf("Aspect-correct: Doom %dx%d -> %dx%d rows + %d row offset (for menus)\n",
+		       DOOMGENERIC_RESX, DOOMGENERIC_RESY, aspectOutW, aspectOutH, aspectOffY);
 	} else {
 		printf("Framebuffer: %dx%d, %d-bit\n", fbWidth, fbHeight, info.bits_per_pixel);
 		
@@ -601,14 +650,33 @@ void DG_DrawFrame() {
 		// Uses precomputed lookup tables to avoid per-pixel division
 		uint32_t *srcBuf = (uint32_t *)DG_ScreenBuffer;
 		
-		for (unsigned int y = 0; y < scaledOutH; y++) {
-			uint16_t *dst = renderBuffer + (y + scaledOffY) * fbWidth;
-			unsigned int srcX = srcXLookup[y];
+		// Use aspect-correct rendering for title/menu screens, stretched for gameplay
+		int useAspectCorrect = (gamestate != GS_LEVEL);
+		
+		if (useAspectCorrect && srcXLookupAspect && srcYLookupAspect) {
+			// Clear buffer first (for black bars at top/bottom)
+			memset(renderBuffer, 0, renderBufferSize);
 			
-			for (unsigned int x = 0; x < scaledOutW; x++) {
-				uint32_t pixel = srcBuf[srcYLookup[x] * DOOMGENERIC_RESX + srcX];
-				// Inline RGB565 conversion (avoid function call overhead)
-				dst[x] = ((pixel >> 8) & 0xF800) | ((pixel >> 5) & 0x07E0) | ((pixel >> 3) & 0x001F);
+			// Render with correct aspect ratio (centered with vertical black bars)
+			for (unsigned int y = 0; y < aspectOutH; y++) {
+				uint16_t *dst = renderBuffer + (y + aspectOffY) * fbWidth;
+				unsigned int srcX = srcXLookupAspect[y];
+				
+				for (unsigned int x = 0; x < aspectOutW; x++) {
+					uint32_t pixel = srcBuf[srcYLookupAspect[x] * DOOMGENERIC_RESX + srcX];
+					dst[x] = ((pixel >> 8) & 0xF800) | ((pixel >> 5) & 0x07E0) | ((pixel >> 3) & 0x001F);
+				}
+			}
+		} else {
+			// Full-screen stretched rendering (gameplay with FOV correction)
+			for (unsigned int y = 0; y < scaledOutH; y++) {
+				uint16_t *dst = renderBuffer + (y + scaledOffY) * fbWidth;
+				unsigned int srcX = srcXLookup[y];
+				
+				for (unsigned int x = 0; x < scaledOutW; x++) {
+					uint32_t pixel = srcBuf[srcYLookup[x] * DOOMGENERIC_RESX + srcX];
+					dst[x] = ((pixel >> 8) & 0xF800) | ((pixel >> 5) & 0x07E0) | ((pixel >> 3) & 0x001F);
+				}
 			}
 		}
 		lseek(fbFd, 0, SEEK_SET);
-- 
2.48.1


From 58ff921262e23d0aaa05027fe59bca75c9f4cf74 Mon Sep 17 00:00:00 2001
From: Luke Macken <luke@farmgpu.com>
Date: Sat, 3 Jan 2026 23:42:41 -0700
Subject: [PATCH 5/7] Add dirty region detection and CPU optimizations for
 smoother gameplay

Dirty region detection:
- Keep previous frame buffer for comparison
- Use memcmp() to find first/last changed rows
- Only write changed portion to display via lseek+write
- Skip write entirely if nothing changed (e.g., pause screens)

CPU optimizations for MIPS 24KEc:
- -march=24kec -mtune=24kec: Target exact CPU
- -mdsp: Enable MIPS DSP ASE instructions
- -ffast-math: Faster floating point operations
- -funroll-loops: Unroll small loops for speed
- -fomit-frame-pointer: Free up a register

Results in smoother gameplay and reduced display latency.
---
 doomgeneric/Makefile.mipsel       |  7 ++++++
 doomgeneric/doomgeneric_linuxvt.c | 40 +++++++++++++++++++++++++++++--
 2 files changed, 45 insertions(+), 2 deletions(-)

diff --git a/doomgeneric/Makefile.mipsel b/doomgeneric/Makefile.mipsel
index 970020d..60cb9e5 100644
--- a/doomgeneric/Makefile.mipsel
+++ b/doomgeneric/Makefile.mipsel
@@ -20,7 +20,14 @@ CFLAGS+=-DDOOMGENERIC_RESX=320 -DDOOMGENERIC_RESY=200
 # Original FOV is 2048, adjusted: 2048 * 1.35 = 2765
 CFLAGS+=-DFIELDOFVIEW=2765
 # Optimize for speed, enable MIPS-specific opts
+# -march=24kec: Target MIPS 24KEc CPU with DSP extensions
+# -mtune=24kec: Optimize scheduling for 24KEc
+# -mdsp: Enable MIPS DSP ASE instructions
+# -ffast-math: Faster floating point (we use soft-float anyway)
+# -funroll-loops: Unroll small loops for speed
+# -fomit-frame-pointer: Free up a register
 CFLAGS+=-O3 -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
+CFLAGS+=-march=24kec -mtune=24kec -mdsp -ffast-math -funroll-loops -fomit-frame-pointer
 LDFLAGS+=-static
 LIBS+=-lm -lc
 
diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index 7e93b5d..e83c288 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -81,6 +81,7 @@ static struct timeval startTime;
 // framebuffer stuff 
 static uint8_t *fbPtr;
 static uint16_t *renderBuffer = NULL;  // Local render buffer for 16-bit mode
+static uint16_t *prevBuffer = NULL;    // Previous frame for dirty detection
 static unsigned int renderBufferSize = 0;
 static int fbFd;
 static int ttyFd = -1;  // TTY for graphics mode switching
@@ -110,6 +111,7 @@ static void cleanup_and_exit(int sig) {
 		close(ttyFd);
 	}
 	if (renderBuffer) free(renderBuffer);
+	if (prevBuffer) free(prevBuffer);
 	if (srcXLookup) free(srcXLookup);
 	if (srcYLookup) free(srcYLookup);
 	if (srcXLookupAspect) free(srcXLookupAspect);
@@ -546,6 +548,12 @@ void DG_Init() {
 			I_Error("Failed to allocate render buffer");
 		memset(renderBuffer, 0, renderBufferSize);
 		
+		// Allocate previous frame buffer for dirty detection
+		prevBuffer = (uint16_t *)malloc(renderBufferSize);
+		if (!prevBuffer)
+			I_Error("Failed to allocate previous frame buffer");
+		memset(prevBuffer, 0, renderBufferSize);
+		
 		// Clear the display
 		lseek(fbFd, 0, SEEK_SET);
 		write(fbFd, renderBuffer, renderBufferSize);
@@ -679,8 +687,36 @@ void DG_DrawFrame() {
 				}
 			}
 		}
-		lseek(fbFd, 0, SEEK_SET);
-		write(fbFd, renderBuffer, renderBufferSize);
+		
+		// Dirty region detection: find first and last changed rows
+		if (prevBuffer) {
+			unsigned int firstDirty = fbHeight;
+			unsigned int lastDirty = 0;
+			size_t rowBytes = fbWidth * sizeof(uint16_t);
+			
+			for (unsigned int y = 0; y < fbHeight; y++) {
+				if (memcmp(renderBuffer + y * fbWidth, prevBuffer + y * fbWidth, rowBytes) != 0) {
+					if (y < firstDirty) firstDirty = y;
+					lastDirty = y;
+				}
+			}
+			
+			if (firstDirty <= lastDirty) {
+				// Write only the changed region
+				size_t offset = firstDirty * rowBytes;
+				size_t length = (lastDirty - firstDirty + 1) * rowBytes;
+				lseek(fbFd, offset, SEEK_SET);
+				write(fbFd, renderBuffer + firstDirty * fbWidth, length);
+			}
+			// else: nothing changed, skip write entirely
+			
+			// Copy current frame to previous for next comparison
+			memcpy(prevBuffer, renderBuffer, renderBufferSize);
+		} else {
+			// No previous buffer, write everything
+			lseek(fbFd, 0, SEEK_SET);
+			write(fbFd, renderBuffer, renderBufferSize);
+		}
 	} else {
 		// Original 32-bit mmap path
 		for (int line = 0; line < DOOMGENERIC_RESY; line++) {
-- 
2.48.1


From f8e962401fb301297aab4f015e2c646031ad71d2 Mon Sep 17 00:00:00 2001
From: Luke Macken <luke@farmgpu.com>
Date: Sun, 4 Jan 2026 09:55:07 -0700
Subject: [PATCH 6/7] Add WiFi Pineapple Pager support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- MIPS cross-compilation Makefile
- QEMU wrapper for running x86_64 SDK on ARM64
- Framebuffer driver with 90° rotation for 222x480 display
- GPIO button support (Green=Enter, Red=Fire)
- Button combos: Red+Green=ESC, Green+D-pad for strafe/use/map
- Aspect ratio correction for menus, FOV adjustment for gameplay
- Dirty region detection for smoother rendering
- Skip quit confirmation dialog
---
 doomgeneric/doomgeneric_linuxvt.c | 55 ++++++++++++++++++++++++++++++-
 doomgeneric/qemu-gcc-wrapper.sh   | 23 ++++++++++++-
 2 files changed, 76 insertions(+), 2 deletions(-)

diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index e83c288..ea2f542 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -130,10 +130,16 @@ static unsigned short s_KeyQueue[KEYQUEUE_SIZE];
 static unsigned int s_KeyQueueWriteIndex = 0;
 static unsigned int s_KeyQueueReadIndex = 0;
 
-// Track button states for combo detection (both buttons = ESC/menu)
+// Track button states for combo detection
 static int redButtonPressed = 0;   // BTN_SOUTH (0x130)
 static int greenButtonPressed = 0; // BTN_EAST (0x131)
 
+// Track D-pad states for green+direction combos
+static int dpadUpPressed = 0;
+static int dpadDownPressed = 0;
+static int dpadLeftPressed = 0;
+static int dpadRightPressed = 0;
+
 // XXX: HACK
 // Linux's evdev system doesn't make it feasible to just use
 // tolower(key) like the existing conversions did, so we
@@ -340,6 +346,12 @@ static void addKeyToQueue(int pressed, unsigned int keyCode) {
 		greenButtonPressed = pressed;
 	}
 	
+	// Track D-pad states
+	if (keyCode == KEY_UP) dpadUpPressed = pressed;
+	else if (keyCode == KEY_DOWN) dpadDownPressed = pressed;
+	else if (keyCode == KEY_LEFT) dpadLeftPressed = pressed;
+	else if (keyCode == KEY_RIGHT) dpadRightPressed = pressed;
+	
 	// Both buttons pressed together = ESC (main menu)
 	if (redButtonPressed && greenButtonPressed && pressed) {
 		unsigned short escData = (1 << 8) | KEY_ESCAPE;
@@ -348,6 +360,47 @@ static void addKeyToQueue(int pressed, unsigned int keyCode) {
 		s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
 		return;  // Don't also send the individual button
 	}
+	
+	// Green + D-pad combos (when green is held)
+	if (greenButtonPressed && pressed) {
+		unsigned char comboKey = 0;
+		
+		if (keyCode == KEY_UP) {
+			comboKey = KEY_USE;  // Open doors/switches (0xa2)
+		} else if (keyCode == KEY_DOWN) {
+			comboKey = DOOM_KEY_TAB;  // Automap toggle
+		} else if (keyCode == KEY_LEFT) {
+			comboKey = KEY_STRAFE_L;  // Strafe left (0xa0)
+		} else if (keyCode == KEY_RIGHT) {
+			comboKey = KEY_STRAFE_R;  // Strafe right (0xa1)
+		}
+		
+		if (comboKey != 0) {
+			unsigned short comboData = (1 << 8) | comboKey;
+			s_KeyQueue[s_KeyQueueWriteIndex] = comboData;
+			s_KeyQueueWriteIndex++;
+			s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
+			return;  // Don't send the regular D-pad key
+		}
+	}
+	
+	// Handle key release for combo keys (need to release the combo key too)
+	if (greenButtonPressed && !pressed) {
+		unsigned char comboKey = 0;
+		
+		if (keyCode == KEY_UP) comboKey = KEY_USE;
+		else if (keyCode == KEY_DOWN) comboKey = DOOM_KEY_TAB;
+		else if (keyCode == KEY_LEFT) comboKey = KEY_STRAFE_L;
+		else if (keyCode == KEY_RIGHT) comboKey = KEY_STRAFE_R;
+		
+		if (comboKey != 0) {
+			unsigned short comboData = (0 << 8) | comboKey;  // Release
+			s_KeyQueue[s_KeyQueueWriteIndex] = comboData;
+			s_KeyQueueWriteIndex++;
+			s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
+			return;
+		}
+	}
 		
 	unsigned char key = convertToDoomKey(keyCode);
 	if (key == 0xFF) // unknown, don't process it
diff --git a/doomgeneric/qemu-gcc-wrapper.sh b/doomgeneric/qemu-gcc-wrapper.sh
index 58a10b4..0d95627 100755
--- a/doomgeneric/qemu-gcc-wrapper.sh
+++ b/doomgeneric/qemu-gcc-wrapper.sh
@@ -1,7 +1,28 @@
 #!/bin/bash
 # Wrapper to run OpenWrt SDK gcc through QEMU
+# Set OPENWRT_SDK environment variable to your SDK path
 
-OPENWRT_SDK="/home/l/code/pineapple/doom/openwrt-sdk-22.03.5-ramips-mt76x8_gcc-11.2.0_musl.Linux-x86_64"
+if [ -z "$OPENWRT_SDK" ]; then
+    # Default: look for SDK in parent directories
+    for dir in "." ".." "../.." "../../.."; do
+        if [ -d "$dir/openwrt-sdk" ]; then
+            OPENWRT_SDK="$(cd "$dir/openwrt-sdk" && pwd)"
+            break
+        fi
+        # Also check for the full name
+        for sdk in "$dir"/openwrt-sdk-*-ramips-mt76x8*; do
+            if [ -d "$sdk" ]; then
+                OPENWRT_SDK="$(cd "$sdk" && pwd)"
+                break 2
+            fi
+        done
+    done
+fi
+
+if [ -z "$OPENWRT_SDK" ] || [ ! -d "$OPENWRT_SDK" ]; then
+    echo "ERROR: OpenWrt SDK not found. Set OPENWRT_SDK environment variable." >&2
+    exit 1
+fi
 TOOLCHAIN_DIR="$OPENWRT_SDK/staging_dir/toolchain-mipsel_24kc_gcc-11.2.0_musl"
 HOST_DIR="$OPENWRT_SDK/staging_dir/host"
 
-- 
2.48.1


From eec5cf3323f208517da23291f4ea117693f7d599 Mon Sep 17 00:00:00 2001
From: Luke Macken <luke@farmgpu.com>
Date: Sun, 4 Jan 2026 12:15:33 -0700
Subject: [PATCH 7/7] Require OPENWRT_SDK env var (no auto-detection)

---
 doomgeneric/qemu-gcc-wrapper.sh | 22 +++++-----------------
 1 file changed, 5 insertions(+), 17 deletions(-)

diff --git a/doomgeneric/qemu-gcc-wrapper.sh b/doomgeneric/qemu-gcc-wrapper.sh
index 0d95627..d1c4fe1 100755
--- a/doomgeneric/qemu-gcc-wrapper.sh
+++ b/doomgeneric/qemu-gcc-wrapper.sh
@@ -1,26 +1,14 @@
 #!/bin/bash
 # Wrapper to run OpenWrt SDK gcc through QEMU
-# Set OPENWRT_SDK environment variable to your SDK path
+# Requires: OPENWRT_SDK environment variable set to SDK path
 
 if [ -z "$OPENWRT_SDK" ]; then
-    # Default: look for SDK in parent directories
-    for dir in "." ".." "../.." "../../.."; do
-        if [ -d "$dir/openwrt-sdk" ]; then
-            OPENWRT_SDK="$(cd "$dir/openwrt-sdk" && pwd)"
-            break
-        fi
-        # Also check for the full name
-        for sdk in "$dir"/openwrt-sdk-*-ramips-mt76x8*; do
-            if [ -d "$sdk" ]; then
-                OPENWRT_SDK="$(cd "$sdk" && pwd)"
-                break 2
-            fi
-        done
-    done
+    echo "ERROR: OPENWRT_SDK environment variable not set" >&2
+    exit 1
 fi
 
-if [ -z "$OPENWRT_SDK" ] || [ ! -d "$OPENWRT_SDK" ]; then
-    echo "ERROR: OpenWrt SDK not found. Set OPENWRT_SDK environment variable." >&2
+if [ ! -d "$OPENWRT_SDK" ]; then
+    echo "ERROR: OPENWRT_SDK path does not exist: $OPENWRT_SDK" >&2
     exit 1
 fi
 TOOLCHAIN_DIR="$OPENWRT_SDK/staging_dir/toolchain-mipsel_24kc_gcc-11.2.0_musl"
-- 
2.48.1

