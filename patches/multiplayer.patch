diff --git a/doomgeneric/Makefile.mipsel b/doomgeneric/Makefile.mipsel
new file mode 100644
index 0000000..123448a
--- /dev/null
+++ b/doomgeneric/Makefile.mipsel
@@ -0,0 +1,78 @@
+################################################################
+#
+# Cross-compilation Makefile for MIPS (mipsel-linux-gnu)
+# For WiFi Pineapple Pager
+#
+
+ifeq ($(V),1)
+	VB=''
+else
+	VB=@
+endif
+
+# OpenWrt SDK musl-based cross-compiler for mipsel_24kc
+# Using QEMU wrapper to run x86-64 SDK on ARM64 host
+CC=$(shell pwd)/qemu-gcc-wrapper.sh
+CROSS_COMPILE=$(shell pwd)/qemu-gcc-wrapper.sh
+# Keep Doom at 320x200 internally, we scale in output code
+CFLAGS+=-DDOOMGENERIC_RESX=320 -DDOOMGENERIC_RESY=200
+# Widen FOV to compensate for aspect ratio stretch (480/320)/(222/200) = 1.35x
+# Original FOV is 2048, adjusted: 2048 * 1.35 = 2765
+CFLAGS+=-DFIELDOFVIEW=2765
+# Optimize for speed
+# -O3: Maximum speed optimization
+# -march=24kec: Target MIPS 24KEc CPU with DSP extensions
+# -mdsp: Enable MIPS DSP ASE instructions
+# -funroll-loops: Unroll loops for speed
+# -ffast-math: Faster floating point
+# -fomit-frame-pointer: Free up a register
+# -fprefetch-loop-arrays: Generate prefetch instructions for arrays (CPU supports it!)
+# -ftree-loop-vectorize: Enable loop vectorization
+# -finline-functions: Inline small functions for speed
+# -mbranch-likely: Use branch likely instructions for better branch prediction
+CFLAGS+=-O3 -Wall -DNORMALUNIX -DLINUX -D_DEFAULT_SOURCE
+CFLAGS+=-march=24kec -mtune=24kec -mdsp -mbranch-likely
+CFLAGS+=-ffast-math -funroll-loops -fomit-frame-pointer
+CFLAGS+=-fprefetch-loop-arrays -finline-functions
+LDFLAGS+=-static
+LIBS+=-lm -lc
+
+# subdirectory for objects
+OBJDIR=build
+OUTPUT=doomgeneric
+
+SRC_DOOM = dummy.o am_map.o doomdef.o doomstat.o dstrings.o d_event.o d_items.o d_iwad.o d_loop.o d_main.o d_mode.o d_net.o f_finale.o f_wipe.o g_game.o hu_lib.o hu_stuff.o info.o i_cdmus.o i_endoom.o i_joystick.o i_scale.o i_sound.o i_system.o i_timer.o memio.o m_argv.o m_bbox.o m_cheat.o m_config.o m_controls.o m_fixed.o m_menu.o m_misc.o m_random.o p_ceilng.o p_doors.o p_enemy.o p_floor.o p_inter.o p_lights.o p_map.o p_maputl.o p_mobj.o p_plats.o p_pspr.o p_saveg.o p_setup.o p_sight.o p_spec.o p_switch.o p_telept.o p_tick.o p_user.o r_bsp.o r_data.o r_draw.o r_main.o r_plane.o r_segs.o r_sky.o r_things.o sha1.o sounds.o statdump.o st_lib.o st_stuff.o s_sound.o tables.o v_video.o wi_stuff.o w_checksum.o w_file.o w_main.o w_wad.o z_zone.o w_file_stdc.o i_input.o i_video.o doomgeneric.o doomgeneric_linuxvt.o mus2mid.o
+
+# Network sources for multiplayer support
+SRC_NET = net_packet.o net_io.o net_socket.o net_client.o net_server.o net_loop.o net_query.o net_dedicated.o net_lobby.o
+
+OBJS += $(addprefix $(OBJDIR)/, $(SRC_DOOM))
+OBJS += $(addprefix $(OBJDIR)/, $(SRC_NET))
+
+all:	 $(OUTPUT)
+
+clean:
+	rm -rf $(OBJDIR)
+	rm -f $(OUTPUT)
+	rm -f $(OUTPUT).gdb
+	rm -f $(OUTPUT).map
+
+$(OUTPUT):	$(OBJS)
+	@echo [Linking $@]
+	$(VB)$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) \
+	-o $(OUTPUT) $(LIBS)
+	@echo [Size]
+	-@size $(OUTPUT) 2>/dev/null || true
+
+$(OBJS): | $(OBJDIR)
+
+$(OBJDIR):
+	mkdir -p $(OBJDIR)
+
+$(OBJDIR)/%.o:	%.c
+	@echo [Compiling $<]
+	$(VB)$(CC) $(CFLAGS) -c $< -o $@
+
+print:
+	@echo OBJS: $(OBJS)
+
diff --git a/doomgeneric/d_loop.c b/doomgeneric/d_loop.c
index 1939dbd..936b441 100644
--- a/doomgeneric/d_loop.c
+++ b/doomgeneric/d_loop.c
@@ -37,9 +37,13 @@
 #include "net_io.h"
 #include "net_query.h"
 #include "net_server.h"
-#include "net_sdl.h"
+#include "net_socket.h"  // Use POSIX sockets instead of SDL_net
 #include "net_loop.h"
 
+// External declarations for network settings received from server
+extern net_gamesettings_t received_settings;
+extern boolean received_settings_valid;
+
 // The complete set of data for a particular tic.
 
 typedef struct
@@ -437,15 +441,90 @@ void D_StartNetGame(net_gamesettings_t *settings,
     //    printf("Syncing netgames like Vanilla Doom.\n");
     //}
 #else
-    settings->consoleplayer = 0;
-	settings->num_players = 1;
-	settings->player_classes[0] = player_class;
-	settings->new_sync = 0;
-	settings->extratics = 1;
-	settings->ticdup = 1;
-
-	ticdup = settings->ticdup;
-	new_sync = settings->new_sync;
+#ifdef FEATURE_MULTIPLAYER
+    // If we're connected to a network game, send GAMESTART and wait for response
+    if (net_client_connected)
+    {
+        // Fill in default settings to send to server
+        settings->ticdup = 1;
+        settings->extratics = 1;
+        settings->deathmatch = 1;  // Deathmatch mode
+        settings->episode = 1;
+        settings->map = 1;
+        settings->skill = 2;  // Medium
+        settings->nomonsters = 0;
+        settings->fast_monsters = 0;
+        settings->respawn_monsters = 0;
+        settings->timelimit = 0;
+        settings->loadgame = -1;
+        settings->lowres_turn = 0;
+        settings->new_sync = 0;
+        settings->gameversion = 0;
+        settings->player_classes[0] = player_class;
+        
+        // Send GAMESTART and wait for server's response
+        extern void NET_CL_SendStartAndWait(net_gamesettings_t *settings);
+        NET_CL_SendStartAndWait(settings);
+        
+        // Now use the received settings from server
+        if (received_settings_valid)
+        {
+            // Copy all settings from what the server sent us
+            settings->consoleplayer = received_settings.consoleplayer;
+            settings->num_players = received_settings.num_players;
+            settings->deathmatch = received_settings.deathmatch;
+            settings->episode = received_settings.episode;
+            settings->map = received_settings.map;
+            settings->skill = received_settings.skill;
+            settings->nomonsters = received_settings.nomonsters;
+            settings->fast_monsters = received_settings.fast_monsters;
+            settings->respawn_monsters = received_settings.respawn_monsters;
+            settings->timelimit = received_settings.timelimit;
+            settings->loadgame = received_settings.loadgame;
+            settings->lowres_turn = received_settings.lowres_turn;
+            settings->new_sync = received_settings.new_sync;
+            settings->extratics = received_settings.extratics;
+            settings->ticdup = received_settings.ticdup;
+            
+            for (int i = 0; i < NET_MAXPLAYERS; i++)
+                settings->player_classes[i] = received_settings.player_classes[i];
+            
+            printf("D_StartNetGame: Using network settings - player %d of %d\n",
+                   settings->consoleplayer + 1, settings->num_players);
+            
+            // CRITICAL: Set localplayer so we control our own character!
+            localplayer = settings->consoleplayer;
+            
+            // Set playeringame for all players
+            for (int i = 0; i < NET_MAXPLAYERS; i++)
+                local_playeringame[i] = i < settings->num_players;
+        }
+        else
+        {
+            printf("D_StartNetGame: ERROR - no valid settings from server!\n");
+            // Fall through to single player defaults
+            settings->consoleplayer = 0;
+            settings->num_players = 1;
+            localplayer = 0;
+            local_playeringame[0] = true;
+        }
+    }
+    else
+#endif
+    {
+        // Single player defaults
+        settings->consoleplayer = 0;
+        settings->num_players = 1;
+        settings->player_classes[0] = player_class;
+        settings->new_sync = 0;
+        settings->extratics = 1;
+        settings->ticdup = 1;
+        localplayer = 0;
+        local_playeringame[0] = true;
+    }
+
+    ticdup = settings->ticdup;
+    new_sync = settings->new_sync;
 #endif
 }
 
@@ -476,7 +555,7 @@ boolean D_InitNetGame(net_connect_data_t *connect_data)
     {
         NET_SV_Init();
         NET_SV_AddModule(&net_loop_server_module);
-        NET_SV_AddModule(&net_sdl_module);
+        NET_SV_AddModule(&net_socket_module);
         NET_SV_RegisterWithMaster();
 
         net_loop_client_module.InitClient();
@@ -515,8 +594,8 @@ boolean D_InitNetGame(net_connect_data_t *connect_data)
 
         if (i > 0)
         {
-            net_sdl_module.InitClient();
-            addr = net_sdl_module.ResolveAddress(myargv[i+1]);
+            net_socket_module.InitClient();
+            addr = net_socket_module.ResolveAddress(myargv[i+1]);
 
             if (addr == NULL)
             {
diff --git a/doomgeneric/d_loop.h b/doomgeneric/d_loop.h
index eb87d84..0506538 100644
--- a/doomgeneric/d_loop.h
+++ b/doomgeneric/d_loop.h
@@ -77,5 +77,14 @@ void D_StartNetGame(net_gamesettings_t *settings,
 extern boolean singletics;
 extern int gametic, ticdup;
 
+// Receive ticcmds from network
+void D_ReceiveTic(ticcmd_t *ticcmds, boolean *players_mask);
+
+// Wait for game launch signal
+void NET_WaitForLaunch(void);
+
+// LAN server discovery
+net_addr_t *NET_FindLANServer(void);
+
 #endif
 
diff --git a/doomgeneric/doomfeatures.h b/doomgeneric/doomfeatures.h
index dff6936..724210e 100644
--- a/doomgeneric/doomfeatures.h
+++ b/doomgeneric/doomfeatures.h
@@ -29,7 +29,7 @@
 
 // Enables multiplayer support (network games)
 
-#undef FEATURE_MULTIPLAYER
+#define FEATURE_MULTIPLAYER
 
 // Enables sound output
 
diff --git a/doomgeneric/doomgeneric_linuxvt.c b/doomgeneric/doomgeneric_linuxvt.c
index ed94dd9..bab7cb7 100644
--- a/doomgeneric/doomgeneric_linuxvt.c
+++ b/doomgeneric/doomgeneric_linuxvt.c
@@ -6,6 +6,8 @@
 #include "m_argv.h"
 #include "doomgeneric.h"
 #include "i_system.h"
+#include "doomdef.h"   // For GS_LEVEL constant
+#include "doomstat.h"  // For gamestate variable
 
 // XXX: HACK
 // Linux's input-event-codes.h and doomkeys.h have many collisions.
@@ -46,6 +48,7 @@
 
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <errno.h>
@@ -58,6 +61,9 @@
 #include <linux/input.h>
 #include <linux/input-event-codes.h>
 #include <linux/fb.h>
+#include <linux/kd.h>
+#include <linux/vt.h>
+#include <signal.h>
 
 #include <stdbool.h>
 
@@ -74,8 +80,45 @@ static struct timeval startTime;
 
 // framebuffer stuff 
 static uint8_t *fbPtr;
-static int fbFd;
-static unsigned int fbWidth, fbHeight, fbStride, fbBytesPerPixel, fbOffsetX, fbOffsetY;
+// These are non-static so net_lobby.c can access them for lobby drawing
+uint16_t *renderBuffer = NULL;  // Local render buffer for 16-bit mode
+size_t renderBufferSize = 0;
+int fbFd;
+static int ttyFd = -1;  // TTY for graphics mode switching
+unsigned int fbWidth, fbHeight;  // Non-static for net_lobby.c access
+static unsigned int fbStride, fbBytesPerPixel, fbOffsetX, fbOffsetY;
+static int fbIs16Bit = 0; // 1 if framebuffer is 16-bit RGB565
+
+// Precomputed lookup tables for scaling (avoids per-pixel division)
+// Full-screen stretched (for gameplay with FOV correction)
+static unsigned int *srcXLookup = NULL;  // For each dest Y, source X
+static unsigned int *srcYLookup = NULL;  // For each dest X, source Y
+static unsigned int scaledOutW = 0;
+static unsigned int scaledOutH = 0;
+static unsigned int scaledOffY = 0;
+
+// Aspect-correct (for title screens/menus - uses black bars)
+static unsigned int *srcXLookupAspect = NULL;
+static unsigned int *srcYLookupAspect = NULL;
+static unsigned int aspectOutW = 0;
+static unsigned int aspectOutH = 0;
+static unsigned int aspectOffY = 0;  // Vertical offset for centering (in display rows)
+
+// Cleanup function for signal handling
+static void cleanup_and_exit(int sig) {
+	// Restore text mode if we switched to graphics mode
+	if (ttyFd >= 0) {
+		ioctl(ttyFd, KDSETMODE, KD_TEXT);
+		close(ttyFd);
+	}
+	if (renderBuffer) free(renderBuffer);
+	if (srcXLookup) free(srcXLookup);
+	if (srcYLookup) free(srcYLookup);
+	if (srcXLookupAspect) free(srcXLookupAspect);
+	if (srcYLookupAspect) free(srcYLookupAspect);
+	if (fbFd >= 0) close(fbFd);
+	_exit(sig ? 128 + sig : 0);
+}
 
 // input stuff
 static int numInputFds = 0;
@@ -87,6 +130,16 @@ static unsigned short s_KeyQueue[KEYQUEUE_SIZE];
 static unsigned int s_KeyQueueWriteIndex = 0;
 static unsigned int s_KeyQueueReadIndex = 0;
 
+// Track button states for combo detection
+static int redButtonPressed = 0;   // BTN_SOUTH (0x130)
+static int greenButtonPressed = 0; // BTN_EAST (0x131)
+
+// Track D-pad states for green+direction combos
+static int dpadUpPressed = 0;
+static int dpadDownPressed = 0;
+static int dpadLeftPressed = 0;
+static int dpadRightPressed = 0;
+
 // XXX: HACK
 // Linux's evdev system doesn't make it feasible to just use
 // tolower(key) like the existing conversions did, so we
@@ -197,6 +250,14 @@ static unsigned char convertToDoomKey(unsigned int key){
 			key = DOOM_KEY_TAB;
 			break;
 
+		// WiFi Pineapple Pager button mappings
+		case 0x130:  // BTN_SOUTH (304) - red button
+			key = KEY_FIRE;
+			break;
+		case 0x131:  // BTN_EAST (305) - green button
+			key = DOOM_KEY_ENTER;
+			break;
+
 		// sadly, yes, we need to handle every single alphanumeric
 		// key here, since evdev doesn't spit out keys in anything
 		// remotely resembling ASCII.....
@@ -273,11 +334,73 @@ static unsigned char convertToDoomKey(unsigned int key){
 	return key;
 }
 
-static void addKeyToQueue(int pressed, unsigned char keyCode) {
+static void addKeyToQueue(int pressed, unsigned int keyCode) {
 	if ((keyCode == KEY_LEFTSHIFT || keyCode == KEY_RIGHTSHIFT) &&
 		(pressed == 1 || pressed == 0))
 		shiftPressed = pressed;
 
+	// Track button states for combo detection
+	if (keyCode == 0x130) {  // Red button
+		redButtonPressed = pressed;
+	} else if (keyCode == 0x131) {  // Green button
+		greenButtonPressed = pressed;
+	}
+	
+	// Track D-pad states
+	if (keyCode == KEY_UP) dpadUpPressed = pressed;
+	else if (keyCode == KEY_DOWN) dpadDownPressed = pressed;
+	else if (keyCode == KEY_LEFT) dpadLeftPressed = pressed;
+	else if (keyCode == KEY_RIGHT) dpadRightPressed = pressed;
+	
+	// Both buttons pressed together = ESC (main menu)
+	if (redButtonPressed && greenButtonPressed && pressed) {
+		unsigned short escData = (1 << 8) | KEY_ESCAPE;
+		s_KeyQueue[s_KeyQueueWriteIndex] = escData;
+		s_KeyQueueWriteIndex++;
+		s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
+		return;  // Don't also send the individual button
+	}
+	
+	// Green + D-pad combos (when green is held)
+	if (greenButtonPressed && pressed) {
+		unsigned char comboKey = 0;
+		
+		if (keyCode == KEY_UP) {
+			comboKey = KEY_USE;  // Open doors/switches (0xa2)
+		} else if (keyCode == KEY_DOWN) {
+			comboKey = DOOM_KEY_TAB;  // Automap toggle
+		} else if (keyCode == KEY_LEFT) {
+			comboKey = KEY_STRAFE_L;  // Strafe left (0xa0)
+		} else if (keyCode == KEY_RIGHT) {
+			comboKey = KEY_STRAFE_R;  // Strafe right (0xa1)
+		}
+		
+		if (comboKey != 0) {
+			unsigned short comboData = (1 << 8) | comboKey;
+			s_KeyQueue[s_KeyQueueWriteIndex] = comboData;
+			s_KeyQueueWriteIndex++;
+			s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
+			return;  // Don't send the regular D-pad key
+		}
+	}
+	
+	// Handle key release for combo keys (need to release the combo key too)
+	if (greenButtonPressed && !pressed) {
+		unsigned char comboKey = 0;
+		
+		if (keyCode == KEY_UP) comboKey = KEY_USE;
+		else if (keyCode == KEY_DOWN) comboKey = DOOM_KEY_TAB;
+		else if (keyCode == KEY_LEFT) comboKey = KEY_STRAFE_L;
+		else if (keyCode == KEY_RIGHT) comboKey = KEY_STRAFE_R;
+		
+		if (comboKey != 0) {
+			unsigned short comboData = (0 << 8) | comboKey;  // Release
+			s_KeyQueue[s_KeyQueueWriteIndex] = comboData;
+			s_KeyQueueWriteIndex++;
+			s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
+			return;
+		}
+	}
 		
 	unsigned char key = convertToDoomKey(keyCode);
 	if (key == 0xFF) // unknown, don't process it
@@ -323,6 +446,31 @@ static void checkKeys() {
 	return;
 }
 
+// Check for lobby-specific input: returns 1=start, -1=quit, 0=nothing
+// Green button (BTN_B/305) = start, Red button (BTN_A/304) = quit
+int DG_CheckLobbyInput(void)
+{
+	int ret, i;
+	struct input_event ev;
+	int result = 0;
+	
+	ret = poll(pollfds, numInputFds, 0);
+	if (ret <= 0) return 0;
+	
+	for (i = 0; i < MAX_INPUT_DEVS; i++) {
+		if (pollfds[i].revents & POLLIN) {
+			read(inputFds[i], &ev, sizeof(ev));
+			if (ev.type == EV_KEY && ev.value == 1) {  // Key press
+				if (ev.code == BTN_B || ev.code == KEY_SPACE || ev.code == KEY_ENTER) {
+					result = 1;  // Start game
+				} else if (ev.code == BTN_A || ev.code == KEY_ESC) {
+					result = -1; // Quit
+				}
+			}
+		}
+	}
+	return result;
+}
 
 #define TEST_KEY(k) (keybits[(k)/8] & (1 << ((k)%8)))
 static int isKeyboard(const char *devPath) {
@@ -353,10 +501,17 @@ static int isKeyboard(const char *devPath) {
 		return 0;
 	}
 
+	/* Accept full keyboards OR any device with button keys (for GPIO buttons) */
 	if (TEST_KEY(KEY_A) && TEST_KEY(KEY_ENTER)) {
 		close(fd);
 		return 1;  /* looks like a keyboard */
 	}
+	
+	/* Also accept devices with BTN_SOUTH/BTN_EAST (Pineapple Pager buttons) */
+	if (TEST_KEY(0x130) || TEST_KEY(0x131)) {
+		close(fd);
+		return 1;  /* has GPIO buttons */
+	}
 
 	close(fd);
 	return 0;
@@ -409,6 +564,30 @@ void DG_Init() {
 	struct fb_var_screeninfo info;
 	struct fb_fix_screeninfo finfo;
 
+	// Set up signal handlers for clean exit
+	signal(SIGINT, cleanup_and_exit);
+	signal(SIGTERM, cleanup_and_exit);
+	signal(SIGSEGV, cleanup_and_exit);
+
+	//
+	// Try to get exclusive graphics mode access
+	// This prevents the console/other apps from interfering
+	//
+	ttyFd = open("/dev/tty0", O_RDWR);
+	if (ttyFd < 0)
+		ttyFd = open("/dev/tty", O_RDWR);
+	if (ttyFd < 0)
+		ttyFd = open("/dev/console", O_RDWR);
+	
+	if (ttyFd >= 0) {
+		// Switch to graphics mode - prevents console from drawing
+		if (ioctl(ttyFd, KDSETMODE, KD_GRAPHICS) == 0) {
+			printf("Switched to graphics mode\n");
+		} else {
+			printf("Warning: Could not switch to graphics mode\n");
+		}
+	}
+
 	//
 	// set up the framebuffer
 	//
@@ -434,19 +613,96 @@ void DG_Init() {
 	fbWidth = info.xres;
 	fbHeight = info.yres;
 	fbBytesPerPixel = info.bits_per_pixel / 8;
+	
+	// Detect 16-bit RGB565 framebuffer
+	if (info.bits_per_pixel == 16) {
+		fbIs16Bit = 1;
+		printf("Framebuffer: %dx%d, 16-bit RGB565\n", fbWidth, fbHeight);
+		
+		// Use write() for SPI displays - mmap causes glitches with fbtft
+		renderBufferSize = fbWidth * fbHeight * sizeof(uint16_t);
+		renderBuffer = (uint16_t *)malloc(renderBufferSize);
+		if (!renderBuffer)
+			I_Error("Failed to allocate render buffer");
+		memset(renderBuffer, 0, renderBufferSize);
+		
+		// Clear the display
+		lseek(fbFd, 0, SEEK_SET);
+		write(fbFd, renderBuffer, renderBufferSize);
+		
+		fbPtr = NULL;
+		fbOffsetX = 0;
+		fbOffsetY = 0;
+		
+		// Fill entire 222x480 display with 320x200 Doom + 90° CCW rotation
+		// After rotation: Doom width (320) -> display height (480), Doom height (200) -> display width (222)
+		// Scale factors: 480/320 = 1.5 for height, 222/200 = 1.11 for width
+		scaledOutW = fbWidth;   // 222 (fills display width)
+		scaledOutH = fbHeight;  // 480 (fills display height)
+		scaledOffY = 0;  // No offset, fills entire screen
+		
+		// Precompute lookup tables for STRETCHED scaling + rotation (gameplay)
+		srcXLookup = (unsigned int *)malloc(scaledOutH * sizeof(unsigned int));
+		srcYLookup = (unsigned int *)malloc(scaledOutW * sizeof(unsigned int));
+		
+		// For each display row (y), compute which Doom column (X) to sample
+		// Display Y maps to Doom X: srcX = y * DoomWidth / displayHeight
+		for (unsigned int y = 0; y < scaledOutH; y++) {
+			srcXLookup[y] = (y * DOOMGENERIC_RESX) / scaledOutH;
+			if (srcXLookup[y] >= DOOMGENERIC_RESX) srcXLookup[y] = DOOMGENERIC_RESX - 1;
+		}
+		// For each display col (x), compute which Doom row (Y) to sample (flipped for CCW)
+		// Display X maps to Doom Y (inverted): srcY = (width-1-x) * DoomHeight / displayWidth
+		for (unsigned int x = 0; x < scaledOutW; x++) {
+			srcYLookup[x] = ((scaledOutW - 1 - x) * DOOMGENERIC_RESY) / scaledOutW;
+			if (srcYLookup[x] >= DOOMGENERIC_RESY) srcYLookup[x] = DOOMGENERIC_RESY - 1;
+		}
+		
+		printf("Full-screen: Doom %dx%d -> Display %dx%d (scaled + rotated)\n", 
+		       DOOMGENERIC_RESX, DOOMGENERIC_RESY, fbWidth, fbHeight);
+		
+		// Precompute lookup tables for ASPECT-CORRECT scaling (title screens)
+		// Display: 222 wide x 480 tall. After 90° CCW rotation from Doom's POV: 480 wide x 222 tall
+		// Doom is 320x200 (1.6:1 aspect). To maintain aspect with 222 vertical pixels:
+		// Scaled width = 222 * (320/200) = 222 * 1.6 = 355 display rows
+		// Black bars: (480 - 355) / 2 = 62 pixels on each side
+		aspectOutW = fbWidth;  // 222 - use full display columns (becomes Doom's vertical)
+		aspectOutH = (aspectOutW * DOOMGENERIC_RESX) / DOOMGENERIC_RESY;  // 222 * 320 / 200 = 355
+		if (aspectOutH > fbHeight) aspectOutH = fbHeight;
+		aspectOffY = (fbHeight - aspectOutH) / 2;  // Center vertically: (480 - 355) / 2 = 62
+		
+		srcXLookupAspect = (unsigned int *)malloc(aspectOutH * sizeof(unsigned int));
+		srcYLookupAspect = (unsigned int *)malloc(aspectOutW * sizeof(unsigned int));
+		
+		// For each output row in the aspect-correct region, which Doom X to sample
+		for (unsigned int y = 0; y < aspectOutH; y++) {
+			srcXLookupAspect[y] = (y * DOOMGENERIC_RESX) / aspectOutH;
+			if (srcXLookupAspect[y] >= DOOMGENERIC_RESX) srcXLookupAspect[y] = DOOMGENERIC_RESX - 1;
+		}
+		// For each output column, which Doom Y to sample (inverted for CCW rotation)
+		for (unsigned int x = 0; x < aspectOutW; x++) {
+			srcYLookupAspect[x] = ((aspectOutW - 1 - x) * DOOMGENERIC_RESY) / aspectOutW;
+			if (srcYLookupAspect[x] >= DOOMGENERIC_RESY) srcYLookupAspect[x] = DOOMGENERIC_RESY - 1;
+		}
+		
+		printf("Aspect-correct: Doom %dx%d -> %dx%d rows + %d row offset (for menus)\n",
+		       DOOMGENERIC_RESX, DOOMGENERIC_RESY, aspectOutW, aspectOutH, aspectOffY);
+	} else {
+		printf("Framebuffer: %dx%d, %d-bit\n", fbWidth, fbHeight, info.bits_per_pixel);
+		
+		// For 32-bit displays, use mmap as normal
+		fbOffsetX = ((fbWidth - DOOMGENERIC_RESX) / 2) * fbBytesPerPixel;
+		fbOffsetY = ((fbHeight - DOOMGENERIC_RESY) / 2) * fbStride;
 
-	// to center the image on screen
-	fbOffsetX = ((fbWidth - DOOMGENERIC_RESX) / 2) * fbBytesPerPixel;
-	fbOffsetY = ((fbHeight - DOOMGENERIC_RESY) / 2) * fbStride;
-
-	fbPtr = mmap(NULL, fbStride * fbHeight, PROT_READ | PROT_WRITE,
-			MAP_SHARED, fbFd, 0);
+		fbPtr = mmap(NULL, fbStride * fbHeight, PROT_READ | PROT_WRITE,
+				MAP_SHARED, fbFd, 0);
 
-	if (!fbPtr)
-		I_Error("Failed to mmap /dev/fb0: %s", strerror(errno));
+		if (!fbPtr)
+			I_Error("Failed to mmap /dev/fb0: %s", strerror(errno));
 
-	// clear the screen
-	memset(fbPtr, 0, fbStride * fbHeight);
+		// clear the screen
+		memset(fbPtr, 0, fbStride * fbHeight);
+	}
 
 	//
 	// set up input
@@ -460,16 +716,91 @@ void DG_Init() {
 	gettimeofday(&startTime, NULL);
 }
 
+// Convert 32-bit ARGB to 16-bit RGB565
+static inline uint16_t rgb32_to_rgb565(uint32_t pixel) {
+	uint8_t r = (pixel >> 16) & 0xFF;
+	uint8_t g = (pixel >> 8) & 0xFF;
+	uint8_t b = pixel & 0xFF;
+	return ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
+}
+
+// Inline RGB8888 to RGB565 conversion
+#define RGB888_TO_RGB565(p) (((p >> 8) & 0xF800) | ((p >> 5) & 0x07E0) | ((p >> 3) & 0x001F))
+
 void DG_DrawFrame() {
-	// we need to do it line-by-line like this to account for the
-	// fact that the system framebuffer resolution is very likely
-	// larger than the doomgeneric render resolution.
-	for (int line = 0; line < DOOMGENERIC_RESY; line++) {
-		memcpy(
-			(void *)((uintptr_t)(fbPtr) + (fbStride * line) + fbOffsetY + fbOffsetX),
+	if (fbIs16Bit) {
+		// Optimized 16-bit RGB565 with 90° CCW rotation
+		// Uses precomputed lookup tables to avoid per-pixel division
+		uint32_t *srcBuf = (uint32_t *)DG_ScreenBuffer;
+		
+		// Use aspect-correct rendering for title/menu screens, stretched for gameplay
+		int useAspectCorrect = (gamestate != GS_LEVEL);
+		
+		if (useAspectCorrect && srcXLookupAspect && srcYLookupAspect) {
+			// Clear buffer first (for black bars at top/bottom)
+			memset(renderBuffer, 0, renderBufferSize);
+			
+			// Render with correct aspect ratio (centered with vertical black bars)
+			for (unsigned int y = 0; y < aspectOutH; y++) {
+				uint16_t *dst = renderBuffer + (y + aspectOffY) * fbWidth;
+				uint32_t *srcRow = srcBuf + srcXLookupAspect[y];
+				
+				// Process 4 pixels at a time when possible
+				unsigned int x = 0;
+				for (; x + 3 < aspectOutW; x += 4) {
+					uint32_t p0 = srcRow[srcYLookupAspect[x] * DOOMGENERIC_RESX];
+					uint32_t p1 = srcRow[srcYLookupAspect[x+1] * DOOMGENERIC_RESX];
+					uint32_t p2 = srcRow[srcYLookupAspect[x+2] * DOOMGENERIC_RESX];
+					uint32_t p3 = srcRow[srcYLookupAspect[x+3] * DOOMGENERIC_RESX];
+					dst[x]   = RGB888_TO_RGB565(p0);
+					dst[x+1] = RGB888_TO_RGB565(p1);
+					dst[x+2] = RGB888_TO_RGB565(p2);
+					dst[x+3] = RGB888_TO_RGB565(p3);
+				}
+				// Handle remaining pixels
+				for (; x < aspectOutW; x++) {
+					uint32_t pixel = srcRow[srcYLookupAspect[x] * DOOMGENERIC_RESX];
+					dst[x] = RGB888_TO_RGB565(pixel);
+				}
+			}
+		} else {
+			// Full-screen stretched rendering (gameplay with FOV correction)
+			for (unsigned int y = 0; y < scaledOutH; y++) {
+				uint16_t *dst = renderBuffer + (y + scaledOffY) * fbWidth;
+				uint32_t *srcRow = srcBuf + srcXLookup[y];
+				
+				// Process 4 pixels at a time when possible
+				unsigned int x = 0;
+				for (; x + 3 < scaledOutW; x += 4) {
+					uint32_t p0 = srcRow[srcYLookup[x] * DOOMGENERIC_RESX];
+					uint32_t p1 = srcRow[srcYLookup[x+1] * DOOMGENERIC_RESX];
+					uint32_t p2 = srcRow[srcYLookup[x+2] * DOOMGENERIC_RESX];
+					uint32_t p3 = srcRow[srcYLookup[x+3] * DOOMGENERIC_RESX];
+					dst[x]   = RGB888_TO_RGB565(p0);
+					dst[x+1] = RGB888_TO_RGB565(p1);
+					dst[x+2] = RGB888_TO_RGB565(p2);
+					dst[x+3] = RGB888_TO_RGB565(p3);
+				}
+				// Handle remaining pixels
+				for (; x < scaledOutW; x++) {
+					uint32_t pixel = srcRow[srcYLookup[x] * DOOMGENERIC_RESX];
+					dst[x] = RGB888_TO_RGB565(pixel);
+				}
+			}
+		}
+		
+		// Write frame to display
+		lseek(fbFd, 0, SEEK_SET);
+		write(fbFd, renderBuffer, renderBufferSize);
+	} else {
+		// Original 32-bit mmap path
+		for (int line = 0; line < DOOMGENERIC_RESY; line++) {
+			memcpy(
+				(void *)((uintptr_t)(fbPtr) + (fbStride * line) + fbOffsetY + fbOffsetX),
 				(void *)(((uintptr_t)DG_ScreenBuffer) + (DOOMGENERIC_RESX * line * fbBytesPerPixel)),
-			 (fbBytesPerPixel * DOOMGENERIC_RESX)
-		);
+				(fbBytesPerPixel * DOOMGENERIC_RESX)
+			);
+		}
 	}
 
 	checkKeys();
diff --git a/doomgeneric/dummy.c b/doomgeneric/dummy.c
index d78816b..0efdd9b 100644
--- a/doomgeneric/dummy.c
+++ b/doomgeneric/dummy.c
@@ -11,6 +11,7 @@
  *---------------------------------------------------------------------*/
 
 #include "doomtype.h"
+#include "doomfeatures.h"
 
 /*---------------------------------------------------------------------*
  *  local definitions                                                  *
@@ -24,9 +25,11 @@
  *  public data                                                        *
  *---------------------------------------------------------------------*/
 
+// net_client_connected and drone now defined in net_client.c when FEATURE_MULTIPLAYER is enabled
+#ifndef FEATURE_MULTIPLAYER
 boolean net_client_connected = false;
-
 boolean drone = false;
+#endif
 
 /*---------------------------------------------------------------------*
  *  private data                                                       *
diff --git a/doomgeneric/g_game.c b/doomgeneric/g_game.c
index 9954d78..20eca54 100644
--- a/doomgeneric/g_game.c
+++ b/doomgeneric/g_game.c
@@ -948,8 +948,8 @@ void G_Ticker (void)
 		if (gametic > BACKUPTICS 
 		    && consistancy[i][buf] != cmd->consistancy) 
 		{ 
-		    I_Error ("consistency failure (%i should be %i)",
-			     cmd->consistancy, consistancy[i][buf]); 
+		    I_Error ("consistency failure for player %i (%i should be %i)",
+			     i, cmd->consistancy, consistancy[i][buf]); 
 		} 
 		if (players[i].mo) 
 		    consistancy[i][buf] = players[i].mo->x; 
diff --git a/doomgeneric/m_menu.c b/doomgeneric/m_menu.c
index 6df9655..4feb72c 100644
--- a/doomgeneric/m_menu.c
+++ b/doomgeneric/m_menu.c
@@ -1167,10 +1167,8 @@ static char *M_SelectEndMessage(void)
 
 void M_QuitDOOM(int choice)
 {
-    DEH_snprintf(endstring, sizeof(endstring), "%s\n\n" DOSY,
-                 DEH_String(M_SelectEndMessage()));
-
-    M_StartMessage(endstring,M_QuitResponse,true);
+    // Skip confirmation on embedded devices (no keyboard for 'y')
+    I_Quit();
 }
 
 
diff --git a/doomgeneric/net_client.c b/doomgeneric/net_client.c
new file mode 100644
index 0000000..964eedc
--- /dev/null
+++ b/doomgeneric/net_client.c
@@ -0,0 +1,1058 @@
+//
+// Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Network client code
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "config.h"
+#include "doomtype.h"
+#include "d_loop.h"
+#include "d_ticcmd.h"
+#include "i_system.h"
+#include "i_timer.h"
+#include "m_argv.h"
+#include "m_misc.h"
+#include "net_client.h"
+#include "net_defs.h"
+#include "net_io.h"
+#include "net_packet.h"
+#include "net_socket.h"
+#include "w_wad.h"
+
+// Connection state
+typedef enum
+{
+    CLIENT_STATE_DISCONNECTED,
+    CLIENT_STATE_CONNECTING,
+    CLIENT_STATE_CONNECTED,
+    CLIENT_STATE_WAITING_START,
+    CLIENT_STATE_IN_GAME,
+} client_state_t;
+
+static client_state_t client_state = CLIENT_STATE_DISCONNECTED;
+static net_addr_t *server_addr = NULL;
+static net_context_t *client_context = NULL;
+
+// Global variables exported to other modules
+boolean net_client_connected = false;
+boolean net_client_received_wait_data = false;
+net_waitdata_t net_client_wait_data;
+boolean net_waiting_for_launch = false;
+char *net_player_name = "Pager";
+
+sha1_digest_t net_server_wad_sha1sum;
+sha1_digest_t net_server_deh_sha1sum;
+unsigned int net_server_is_freedoom = 0;
+sha1_digest_t net_local_wad_sha1sum;
+sha1_digest_t net_local_deh_sha1sum;
+unsigned int net_local_is_freedoom = 0;
+
+boolean drone = false;
+
+// Game settings received from server
+// Received game settings from server (non-static for d_loop.c access)
+net_gamesettings_t received_settings;
+boolean received_settings_valid = false;
+
+// Send queue - stores ticcmd diffs for retransmission
+typedef struct
+{
+    boolean active;
+    unsigned int seq;
+    unsigned int time;  // Time command was generated
+    unsigned int diff;  // Diff bitfield
+    ticcmd_t cmd;       // The full ticcmd
+} net_send_queue_t;
+
+#define BACKUPTICS 128
+static net_send_queue_t send_queue[BACKUPTICS];
+static ticcmd_t last_ticcmd;  // For calculating diffs
+
+// Receive window - baseline ticcmds for patching diffs (per-player)
+static ticcmd_t recvwindow_cmd_base[NET_MAXPLAYERS];
+
+// Last time we sent a packet
+static unsigned int last_send_time = 0;
+static unsigned int last_gamedata_time = 0;
+static unsigned int last_packet_send_time = 0;  // For keepalive
+
+// Connection sequence number
+static unsigned int connect_seq = 0;
+
+// Local player number
+static int local_player = 0;
+
+// Receive window - tracks which tic we're expecting
+static unsigned int recvwindow_start = 0;
+
+// Track the next expected reliable sequence number
+static unsigned int reliable_recv_seq = 0;
+
+// Expand a low byte tic number to a full tic number relative to recvwindow_start
+static unsigned int NET_CL_ExpandTicNum(unsigned int b)
+{
+    unsigned int l, h;
+    unsigned int result;
+
+    h = recvwindow_start & ~0xff;
+    l = recvwindow_start & 0xff;
+
+    result = h | b;
+
+    if (l < 0x40 && b > 0xb0)
+        result -= 0x100;
+    if (l > 0xb0 && b < 0x40)
+        result += 0x100;
+    
+    return result;
+}
+
+static void NET_CL_SendSyn(net_connect_data_t *data);
+static void NET_CL_ParsePacket(net_packet_t *packet);
+static void NET_CL_SendReliableACK(unsigned int seq);
+static void NET_CL_SendGameDataACK(void);
+static void NET_CL_SendTics(int starttic, int endtic);
+
+// Track last reliable sequence we ACKed to avoid duplicate ACKs
+static unsigned int last_acked_seq = 0xFF;
+
+void NET_CL_Init(void)
+{
+    client_context = NET_NewContext();
+    NET_AddModule(client_context, &net_socket_module);
+}
+
+boolean NET_CL_Connect(net_addr_t *addr, net_connect_data_t *data)
+{
+    int start_time;
+    int attempts;
+
+    if (client_state != CLIENT_STATE_DISCONNECTED)
+    {
+        fprintf(stderr, "NET_CL_Connect: Already connected\n");
+        return false;
+    }
+
+    // Initialize socket module
+    if (!net_socket_module.InitClient())
+    {
+        fprintf(stderr, "NET_CL_Connect: Failed to init socket\n");
+        return false;
+    }
+
+    server_addr = addr;
+    client_state = CLIENT_STATE_CONNECTING;
+    connect_seq = 0;
+    last_packet_send_time = I_GetTimeMS();  // Initialize keepalive timer
+
+    printf("NET_CL_Connect: Connecting to %s...\n", NET_AddrToString(addr));
+
+    // Try to connect with timeout
+    start_time = I_GetTimeMS();
+    attempts = 0;
+
+    while (client_state == CLIENT_STATE_CONNECTING)
+    {
+        // Send SYN packet
+        if (I_GetTimeMS() - last_send_time > 500)
+        {
+            NET_CL_SendSyn(data);
+            last_send_time = I_GetTimeMS();
+            attempts++;
+            printf("NET_CL_Connect: Attempt %d...\n", attempts);
+        }
+
+        // Check for response
+        NET_CL_Run();
+
+        // Timeout after 10 seconds
+        if (I_GetTimeMS() - start_time > 10000)
+        {
+            fprintf(stderr, "NET_CL_Connect: Connection timed out\n");
+            client_state = CLIENT_STATE_DISCONNECTED;
+            return false;
+        }
+
+        I_Sleep(10);
+    }
+
+    if (client_state == CLIENT_STATE_CONNECTED ||
+        client_state == CLIENT_STATE_WAITING_START)
+    {
+        printf("NET_CL_Connect: Connected!\n");
+        net_client_connected = true;
+        return true;
+    }
+
+    return false;
+}
+
+static void NET_CL_SendSyn(net_connect_data_t *data)
+{
+    net_packet_t *packet;
+
+    packet = NET_NewPacket(256);
+    if (packet == NULL)
+        return;
+
+    // Packet type
+    NET_WriteInt16(packet, NET_PACKET_TYPE_SYN);
+    
+    // Magic number
+    NET_WriteInt32(packet, NET_MAGIC_NUMBER);
+    
+    // Version string (must match format server expects)
+    NET_WriteString(packet, "Chocolate Doom 3.1.1");
+    
+    // Protocol list: count followed by protocol name strings
+    NET_WriteInt8(packet, 1);  // We support 1 protocol
+    NET_WriteString(packet, "CHOCOLATE_DOOM_0");
+    
+    // Connect data
+    NET_WriteInt8(packet, data->gamemode);
+    NET_WriteInt8(packet, data->gamemission);
+    NET_WriteInt8(packet, data->lowres_turn);
+    NET_WriteInt8(packet, data->drone);
+    NET_WriteInt8(packet, data->max_players);
+    NET_WriteInt8(packet, data->is_freedoom);
+
+    // WAD SHA1
+    for (int i = 0; i < 20; i++)
+        NET_WriteInt8(packet, data->wad_sha1sum[i]);
+
+    // DEH SHA1
+    for (int i = 0; i < 20; i++)
+        NET_WriteInt8(packet, data->deh_sha1sum[i]);
+
+    NET_WriteInt8(packet, data->player_class);
+    
+    // Player name
+    NET_WriteString(packet, net_player_name);
+
+    NET_SendPacket(server_addr, packet);
+    NET_FreePacket(packet);
+}
+
+static void NET_CL_SendReliableACK(unsigned int seq)
+{
+    net_packet_t *packet;
+    
+    // Check if this is the sequence we expected
+    if (seq == (reliable_recv_seq & 0xff))
+    {
+        // Accept this packet and increment our expected sequence
+        reliable_recv_seq = (reliable_recv_seq + 1) & 0xff;
+    }
+    // If not the expected sequence, still ACK but don't increment
+    // (this handles retries and out-of-order packets)
+    
+    packet = NET_NewPacket(16);
+    if (packet == NULL)
+        return;
+    
+    // ACK contains the NEXT expected sequence number
+    NET_WriteInt16(packet, NET_PACKET_TYPE_RELIABLE_ACK);
+    NET_WriteInt8(packet, reliable_recv_seq & 0xFF);
+    
+    NET_SendPacket(server_addr, packet);
+    NET_FreePacket(packet);
+}
+
+// Send acknowledgment for received game data
+static void NET_CL_SendGameDataACK(void)
+{
+    net_packet_t *packet;
+    
+    packet = NET_NewPacket(10);
+    if (packet == NULL)
+        return;
+    
+    NET_WriteInt16(packet, NET_PACKET_TYPE_GAMEDATA_ACK);
+    NET_WriteInt8(packet, recvwindow_start & 0xFF);
+    
+    NET_SendPacket(server_addr, packet);
+    NET_FreePacket(packet);
+}
+
+void NET_CL_Disconnect(void)
+{
+    net_packet_t *packet;
+
+    if (!net_client_connected)
+        return;
+
+    // Send disconnect packet
+    packet = NET_NewPacket(16);
+    if (packet != NULL)
+    {
+        NET_WriteInt16(packet, NET_PACKET_TYPE_DISCONNECT);
+        NET_SendPacket(server_addr, packet);
+        NET_FreePacket(packet);
+    }
+
+    NET_Socket_Shutdown();
+    client_state = CLIENT_STATE_DISCONNECTED;
+    net_client_connected = false;
+}
+
+void NET_CL_Run(void)
+{
+    net_addr_t *addr;
+    net_packet_t *packet;
+    unsigned int nowtime;
+
+    if (client_context == NULL)
+        return;
+
+    // Receive and process packets
+    while (NET_RecvPacket(client_context, &addr, &packet))
+    {
+        NET_CL_ParsePacket(packet);
+        NET_FreePacket(packet);
+        NET_FreeAddress(addr);
+    }
+    
+    // Send keepalive if we haven't sent anything recently (every 1 second)
+    // Server disconnects clients after 30 seconds of silence!
+    nowtime = I_GetTimeMS();
+    if (net_client_connected && (nowtime - last_packet_send_time > 1000))
+    {
+        packet = NET_NewPacket(16);
+        if (packet != NULL)
+        {
+            NET_WriteInt16(packet, NET_PACKET_TYPE_KEEPALIVE);
+            NET_SendPacket(server_addr, packet);
+            NET_FreePacket(packet);
+            last_packet_send_time = nowtime;
+        }
+    }
+}
+
+static void NET_CL_ParsePacket(net_packet_t *packet)
+{
+    unsigned int packet_type;
+    unsigned int is_reliable;
+    unsigned int reliable_seq = 0;
+
+    if (!NET_ReadInt16(packet, &packet_type))
+        return;
+
+    // Check for reliable packet flag (bit 15)
+    is_reliable = packet_type & NET_RELIABLE_PACKET;
+    packet_type = packet_type & ~NET_RELIABLE_PACKET;
+    
+    // Read reliable sequence number and send ACK
+    if (is_reliable)
+    {
+        if (!NET_ReadInt8(packet, &reliable_seq))
+            return;
+        NET_CL_SendReliableACK(reliable_seq);
+    }
+    
+    // Debug output - only for non-GAMEDATA packets to reduce spam
+    if (packet_type != NET_PACKET_TYPE_GAMEDATA && packet_type != NET_PACKET_TYPE_GAMEDATA_RESEND)
+    {
+        fprintf(stderr, "NET_CL_ParsePacket: type=%d reliable=%d seq=%d\n", 
+                packet_type, is_reliable ? 1 : 0, reliable_seq);
+    }
+
+    switch (packet_type)
+    {
+        case NET_PACKET_TYPE_SYN:
+        {
+            // Server's SYN response - connection accepted!
+            // Read server version string
+            char *server_version = NET_ReadString(packet);
+            if (server_version != NULL)
+            {
+                fprintf(stderr, "NET_CL_ParsePacket: Server version: %s\n", server_version);
+            }
+            
+            // Read server's protocol
+            char *protocol = NET_ReadString(packet);
+            if (protocol != NULL)
+            {
+                fprintf(stderr, "NET_CL_ParsePacket: Protocol: %s\n", protocol);
+            }
+            
+            // Connection successful!
+            printf("NET_CL_ParsePacket: Connected to server!\n");
+            client_state = CLIENT_STATE_WAITING_START;
+            break;
+        }
+        
+        case NET_PACKET_TYPE_ACK:
+        {
+            // Legacy: Connection accepted (deprecated but handle anyway)
+            unsigned int player;
+            if (NET_ReadInt8(packet, &player))
+            {
+                local_player = player;
+                printf("NET_CL_ParsePacket: Accepted as player %d\n", local_player);
+                client_state = CLIENT_STATE_WAITING_START;
+            }
+            break;
+        }
+
+        case NET_PACKET_TYPE_REJECTED:
+        {
+            char *reason = NET_ReadString(packet);
+            if (reason != NULL)
+                fprintf(stderr, "Connection rejected: %s\n", reason);
+            client_state = CLIENT_STATE_DISCONNECTED;
+            break;
+        }
+
+        case NET_PACKET_TYPE_WAITING_DATA:
+        {
+            // Server is waiting for more players - read full wait data
+            char *s;
+            int i;
+            
+            NET_ReadInt8(packet, (unsigned int *)&net_client_wait_data.num_players);
+            NET_ReadInt8(packet, (unsigned int *)&net_client_wait_data.num_drones);
+            NET_ReadInt8(packet, (unsigned int *)&net_client_wait_data.ready_players);
+            NET_ReadInt8(packet, (unsigned int *)&net_client_wait_data.max_players);
+            NET_ReadInt8(packet, (unsigned int *)&net_client_wait_data.is_controller);
+            NET_ReadInt8(packet, (unsigned int *)&net_client_wait_data.consoleplayer);
+            
+            // Read player names and addresses
+            for (i = 0; i < net_client_wait_data.num_players && i < NET_MAXPLAYERS; i++) {
+                s = NET_ReadString(packet);
+                if (s != NULL) {
+                    strncpy(net_client_wait_data.player_names[i], s, MAXPLAYERNAME - 1);
+                    net_client_wait_data.player_names[i][MAXPLAYERNAME - 1] = '\0';
+                }
+                
+                s = NET_ReadString(packet);
+                if (s != NULL) {
+                    strncpy(net_client_wait_data.player_addrs[i], s, MAXPLAYERNAME - 1);
+                    net_client_wait_data.player_addrs[i][MAXPLAYERNAME - 1] = '\0';
+                }
+            }
+            
+            // Skip SHA1 sums and freedoom flag (we don't validate them)
+            // wad_sha1sum (20 bytes), deh_sha1sum (20 bytes), is_freedoom (1 byte)
+            
+            net_client_received_wait_data = true;
+            break;
+        }
+
+        case NET_PACKET_TYPE_GAMESTART:
+        {
+            unsigned int random_val;
+            extern int prndindex;  // From m_random.c - P_Random seed
+            extern int rndindex;   // From m_random.c - M_Random seed (used in consistency)
+            
+            fprintf(stderr, "NET_CL_ParsePacket: Received GAMESTART!\n");
+            // Game is starting - read settings in CORRECT ORDER per chocolate-doom
+            // Order: ticdup, extratics, deathmatch, nomonsters, fast_monsters, respawn_monsters,
+            //        episode, map, skill, gameversion, lowres_turn, new_sync, timelimit(32!),
+            //        loadgame, random, num_players, consoleplayer, player_classes[]
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.ticdup);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.extratics);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.deathmatch);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.nomonsters);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.fast_monsters);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.respawn_monsters);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.episode);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.map);
+            NET_ReadSInt8(packet, &received_settings.skill);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.gameversion);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.lowres_turn);
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.new_sync);
+            NET_ReadInt32(packet, (unsigned int *)&received_settings.timelimit);  // INT32!
+            NET_ReadSInt8(packet, &received_settings.loadgame);
+            NET_ReadInt8(packet, &random_val);  // random field - CRITICAL for sync!
+            NET_ReadInt8(packet, (unsigned int *)&received_settings.num_players);
+            NET_ReadSInt8(packet, &received_settings.consoleplayer);
+            
+            // Set the random seed to match server - CRITICAL for game sync!
+            prndindex = random_val;
+            rndindex = random_val;
+            fprintf(stderr, "NET_CL_ParsePacket: Random seed set to %d\n", random_val);
+
+            fprintf(stderr, "NET_CL_ParsePacket: GAMESTART parsed: ep=%d map=%d players=%d console=%d\n",
+                    received_settings.episode, received_settings.map,
+                    received_settings.num_players, received_settings.consoleplayer);
+
+            for (int i = 0; i < received_settings.num_players && i < NET_MAXPLAYERS; i++)
+                NET_ReadInt8(packet, (unsigned int *)&received_settings.player_classes[i]);
+
+            received_settings_valid = true;
+            client_state = CLIENT_STATE_IN_GAME;
+            net_waiting_for_launch = false;
+            
+            // Initialize send queue, last_ticcmd, and receive window baseline
+            memset(send_queue, 0, sizeof(send_queue));
+            memset(&last_ticcmd, 0, sizeof(last_ticcmd));
+            memset(recvwindow_cmd_base, 0, sizeof(recvwindow_cmd_base));
+            recvwindow_start = 0;
+            
+            printf("NET_CL_ParsePacket: Game starting! We are player %d (consoleplayer=%d) of %d\n",
+                   received_settings.consoleplayer + 1,
+                   received_settings.consoleplayer,
+                   received_settings.num_players);
+            fprintf(stderr, "DEBUG: consoleplayer=%d, num_players=%d\n",
+                    received_settings.consoleplayer, received_settings.num_players);
+            break;
+        }
+
+        case NET_PACKET_TYPE_GAMEDATA:
+        {
+            // Game data from server - CORRECT FORMAT:
+            // int8: start_tic (low byte)
+            // int8: num_tics
+            // For each tic:
+            //   int16: latency
+            //   int8: playeringame bitfield (bit 0 = player 0, etc)
+            //   For each player in bitfield: ticcmd diff
+            
+            unsigned int start_tic;
+            unsigned int num_tics;
+            unsigned int tic_idx;
+            
+            if (!NET_ReadInt8(packet, &start_tic))
+                break;
+            if (!NET_ReadInt8(packet, &num_tics))
+                break;
+            
+            // Expand start_tic from low byte to full value
+            // (server only sends low byte, we reconstruct full value)
+            start_tic = NET_CL_ExpandTicNum(start_tic);
+            
+            // Process each tic in the packet
+            for (tic_idx = 0; tic_idx < num_tics; tic_idx++)
+            {
+                unsigned int current_tic = start_tic + tic_idx;
+                signed int latency;
+                unsigned int bitfield;
+                ticcmd_t ticcmds[NET_MAXPLAYERS];
+                boolean playeringame[NET_MAXPLAYERS];
+                
+                // Start from baseline (previous state), not zero!
+                memcpy(ticcmds, recvwindow_cmd_base, sizeof(ticcmds));
+                memset(playeringame, 0, sizeof(playeringame));
+                
+                // Read latency
+                if (!NET_ReadSInt16(packet, &latency))
+                    break;
+                
+                // Read playeringame BITFIELD (single byte, not 8 separate bytes!)
+                if (!NET_ReadInt8(packet, &bitfield))
+                    break;
+                
+                // Convert bitfield to array
+                for (int i = 0; i < NET_MAXPLAYERS; i++)
+                    playeringame[i] = (bitfield & (1 << i)) != 0;
+                
+                // Read ticcmd for each active player
+                for (int i = 0; i < NET_MAXPLAYERS; i++)
+                {
+                    if (playeringame[i])
+                    {
+                        unsigned int diff;
+                        signed int sval;
+                        unsigned int uval;
+                        
+                        if (!NET_ReadInt8(packet, &diff))
+                            break;
+                        
+                        // Skip our own player - we use our local ticcmd, not the relayed one
+                        // But we still need to read the diff data to advance the packet position
+                        if (i == received_settings.consoleplayer && !drone)
+                        {
+                            // Just skip the diff data - don't apply it
+                            if (diff & NET_TICDIFF_FORWARD)
+                                NET_ReadSInt8(packet, &sval);
+                            if (diff & NET_TICDIFF_SIDE)
+                                NET_ReadSInt8(packet, &sval);
+                            if (diff & NET_TICDIFF_TURN)
+                            {
+                                if (received_settings.lowres_turn)
+                                    NET_ReadSInt8(packet, &sval);
+                                else
+                                    NET_ReadSInt16(packet, &sval);
+                            }
+                            if (diff & NET_TICDIFF_BUTTONS)
+                                NET_ReadInt8(packet, &uval);
+                            if (diff & NET_TICDIFF_CONSISTANCY)
+                                NET_ReadInt8(packet, &uval);
+                            if (diff & NET_TICDIFF_CHATCHAR)
+                                NET_ReadInt8(packet, &uval);
+                            if (diff & NET_TICDIFF_RAVEN)
+                            {
+                                NET_ReadInt8(packet, &uval);
+                                NET_ReadInt8(packet, &uval);
+                            }
+                            if (diff & NET_TICDIFF_STRIFE)
+                            {
+                                NET_ReadInt8(packet, &uval);
+                                NET_ReadInt16(packet, &uval);
+                            }
+                            continue;  // Don't update baseline for our own player
+                        }
+                        
+                        // Now process other players' ticcmds normally
+                        if (diff & NET_TICDIFF_FORWARD)
+                        {
+                            NET_ReadSInt8(packet, &sval);
+                            ticcmds[i].forwardmove = sval;
+                        }
+                        if (diff & NET_TICDIFF_SIDE)
+                        {
+                            NET_ReadSInt8(packet, &sval);
+                            ticcmds[i].sidemove = sval;
+                        }
+                        if (diff & NET_TICDIFF_TURN)
+                        {
+                            // Check for lowres_turn mode
+                            if (received_settings.lowres_turn)
+                            {
+                                NET_ReadSInt8(packet, &sval);
+                                ticcmds[i].angleturn = sval * 256;
+                            }
+                            else
+                            {
+                                NET_ReadSInt16(packet, &sval);
+                                ticcmds[i].angleturn = sval;
+                            }
+                        }
+                        if (diff & NET_TICDIFF_BUTTONS)
+                        {
+                            NET_ReadInt8(packet, &uval);
+                            ticcmds[i].buttons = uval;
+                        }
+                        if (diff & NET_TICDIFF_CONSISTANCY)
+                        {
+                            NET_ReadInt8(packet, &uval);
+                            ticcmds[i].consistancy = uval;
+                        }
+                        // else: Consistency not in diff - using baseline value
+                        // Handle optional chatchar - MUST zero if not in diff (per Chocolate Doom)
+                        if (diff & NET_TICDIFF_CHATCHAR)
+                        {
+                            NET_ReadInt8(packet, &uval);
+                            ticcmds[i].chatchar = uval;
+                        }
+                        else
+                        {
+                            ticcmds[i].chatchar = 0;
+                        }
+                        
+                        // Raven (Heretic/Hexen) - not used in Doom but parse anyway
+                        if (diff & NET_TICDIFF_RAVEN)
+                        {
+                            NET_ReadInt8(packet, &uval);  // lookfly
+                            NET_ReadInt8(packet, &uval);  // arti
+                        }
+                        
+                        // Strife - not used in Doom but parse anyway
+                        if (diff & NET_TICDIFF_STRIFE)
+                        {
+                            NET_ReadInt8(packet, &uval);   // buttons2
+                            NET_ReadInt16(packet, &uval);  // inventory
+                        }
+                        
+                        // Update baseline for this player for next diff
+                        recvwindow_cmd_base[i] = ticcmds[i];
+                    }
+                }
+                
+                // Only deliver if this is the tic we're expecting
+                // This ensures sequential processing even if packets arrive out of order
+                if (current_tic == recvwindow_start)
+                {
+                    // Deliver to game loop
+                    D_ReceiveTic(ticcmds, playeringame);
+                    
+                    // Advance receive window
+                    recvwindow_start++;
+                }
+                // else if current_tic > recvwindow_start: out of order - skip
+                // else if current_tic < recvwindow_start: duplicate - ignore
+            }
+            
+            last_gamedata_time = I_GetTimeMS();
+            
+            // Send ACK after processing all tics
+            NET_CL_SendGameDataACK();
+            break;
+        }
+
+        case NET_PACKET_TYPE_GAMEDATA_RESEND:
+        {
+            // Server is asking us to resend our GAMEDATA
+            // The packet contains: start tic (int32) + num_tics (int8)
+            unsigned int start_tic;
+            unsigned int num_tics;
+            unsigned int end_tic;
+            
+            if (!NET_ReadInt32(packet, &start_tic))
+                break;
+            if (!NET_ReadInt8(packet, &num_tics))
+                break;
+            
+            end_tic = start_tic + num_tics - 1;
+            
+            // Trim range to what we actually have in send queue
+            while (start_tic <= end_tic
+                && (!send_queue[start_tic % BACKUPTICS].active
+                 || send_queue[start_tic % BACKUPTICS].seq != start_tic))
+            {
+                start_tic++;
+            }
+            
+            while (start_tic <= end_tic
+                && (!send_queue[end_tic % BACKUPTICS].active
+                 || send_queue[end_tic % BACKUPTICS].seq != end_tic))
+            {
+                end_tic--;
+            }
+            
+            // Resend the tics we have
+            if (start_tic <= end_tic)
+            {
+                NET_CL_SendTics(start_tic, end_tic);
+            }
+            break;
+        }
+
+        case NET_PACKET_TYPE_LAUNCH:
+        {
+            fprintf(stderr, "NET_CL_ParsePacket: Received LAUNCH signal!\n");
+            net_waiting_for_launch = false;
+            fprintf(stderr, "NET_CL_ParsePacket: net_waiting_for_launch = %d\n", net_waiting_for_launch);
+            break;
+        }
+
+        case NET_PACKET_TYPE_DISCONNECT:
+        case NET_PACKET_TYPE_DISCONNECT_ACK:
+        {
+            printf("NET_CL_ParsePacket: Server disconnected\n");
+            client_state = CLIENT_STATE_DISCONNECTED;
+            net_client_connected = false;
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+static unsigned int reliable_send_seq = 0;
+
+void NET_CL_LaunchGame(void)
+{
+    net_packet_t *packet;
+
+    if (!net_client_connected)
+        return;
+
+    fprintf(stderr, "NET_CL_LaunchGame: Sending LAUNCH as reliable packet\n");
+    
+    packet = NET_NewPacket(16);
+    if (packet != NULL)
+    {
+        // Send as reliable packet (like Chocolate Doom does)
+        NET_WriteInt16(packet, NET_PACKET_TYPE_LAUNCH | NET_RELIABLE_PACKET);
+        NET_WriteInt8(packet, reliable_send_seq & 0xFF);
+        reliable_send_seq++;
+        NET_SendPacket(server_addr, packet);
+        NET_FreePacket(packet);
+    }
+}
+
+void NET_CL_StartGame(net_gamesettings_t *settings)
+{
+    // Send game start request - MUST match chocolate-doom NET_WriteSettings order
+    net_packet_t *packet;
+    int i;
+
+    if (!net_client_connected)
+        return;
+
+    fprintf(stderr, "NET_CL_StartGame: Sending GAMESTART request (reliable)\n");
+
+    packet = NET_NewPacket(128);
+    if (packet != NULL)
+    {
+        // Send as reliable packet: set NET_RELIABLE_PACKET flag + sequence
+        NET_WriteInt16(packet, NET_PACKET_TYPE_GAMESTART | NET_RELIABLE_PACKET);
+        NET_WriteInt8(packet, reliable_send_seq & 0xFF);
+        reliable_send_seq++;
+        
+        // Game settings - order MUST match NET_WriteSettings/NET_ReadSettings
+        NET_WriteInt8(packet, settings->ticdup);
+        NET_WriteInt8(packet, settings->extratics);
+        NET_WriteInt8(packet, settings->deathmatch);
+        NET_WriteInt8(packet, settings->nomonsters);
+        NET_WriteInt8(packet, settings->fast_monsters);
+        NET_WriteInt8(packet, settings->respawn_monsters);
+        NET_WriteInt8(packet, settings->episode);
+        NET_WriteInt8(packet, settings->map);
+        NET_WriteInt8(packet, settings->skill);
+        NET_WriteInt8(packet, settings->gameversion);
+        NET_WriteInt8(packet, settings->lowres_turn);
+        NET_WriteInt8(packet, settings->new_sync);
+        NET_WriteInt32(packet, settings->timelimit);  // INT32!
+        NET_WriteInt8(packet, settings->loadgame);
+        NET_WriteInt8(packet, 0);  // random
+        NET_WriteInt8(packet, settings->num_players > 0 ? settings->num_players : 2);  // num_players
+        NET_WriteInt8(packet, settings->consoleplayer);  // consoleplayer
+        
+        // Player classes for each player
+        for (i = 0; i < NET_MAXPLAYERS; i++)
+        {
+            NET_WriteInt8(packet, settings->player_classes[i]);
+        }
+
+        NET_SendPacket(server_addr, packet);
+        NET_FreePacket(packet);
+    }
+}
+
+// Write a single ticcmd diff to the packet
+static void WriteTiccmdDiff(net_packet_t *packet, net_send_queue_t *sendobj)
+{
+    unsigned int diff = sendobj->diff;
+    ticcmd_t *cmd = &sendobj->cmd;
+    
+    NET_WriteInt8(packet, diff);
+    
+    if (diff & NET_TICDIFF_FORWARD)
+        NET_WriteInt8(packet, (unsigned int)cmd->forwardmove);
+    if (diff & NET_TICDIFF_SIDE)
+        NET_WriteInt8(packet, (unsigned int)cmd->sidemove);
+    if (diff & NET_TICDIFF_TURN)
+    {
+        if (received_settings.lowres_turn)
+            NET_WriteInt8(packet, cmd->angleturn >> 8);
+        else
+            NET_WriteInt16(packet, cmd->angleturn);
+    }
+    if (diff & NET_TICDIFF_BUTTONS)
+        NET_WriteInt8(packet, cmd->buttons);
+    if (diff & NET_TICDIFF_CONSISTANCY)
+        NET_WriteInt8(packet, cmd->consistancy);
+}
+
+// Send ticcmds from starttic to endtic
+static void NET_CL_SendTics(int starttic, int endtic)
+{
+    net_packet_t *packet;
+    int i;
+    
+    if (!net_client_connected || client_state != CLIENT_STATE_IN_GAME)
+        return;
+    
+    if (starttic < 0)
+        starttic = 0;
+    
+    packet = NET_NewPacket(512);
+    if (packet == NULL)
+        return;
+    
+    // Header: type, ack, start, num_tics
+    NET_WriteInt16(packet, NET_PACKET_TYPE_GAMEDATA);
+    NET_WriteInt8(packet, recvwindow_start & 0xFF);
+    NET_WriteInt8(packet, starttic & 0xFF);
+    NET_WriteInt8(packet, endtic - starttic + 1);
+    
+    // Write each tic - but first count how many we actually have
+    int actual_tics = 0;
+    for (i = starttic; i <= endtic; i++)
+    {
+        net_send_queue_t *sendobj = &send_queue[i % BACKUPTICS];
+        if (sendobj->active && sendobj->seq == (unsigned int)i)
+            actual_tics++;
+        else
+            break;  // Stop at first missing tic
+    }
+    
+    if (actual_tics == 0)
+    {
+        NET_FreePacket(packet);
+        return;
+    }
+    
+    // Update num_tics in packet (position 4, after type(2)+ack(1)+start(1))
+    packet->data[4] = actual_tics;
+    
+    // Write each tic
+    for (i = starttic; i < starttic + actual_tics; i++)
+    {
+        net_send_queue_t *sendobj = &send_queue[i % BACKUPTICS];
+        
+        // Latency - time since we created this tic
+        int latency = I_GetTimeMS() - sendobj->time;
+        if (latency < 0) latency = 0;
+        NET_WriteInt16(packet, latency);
+        
+        // Ticcmd diff
+        WriteTiccmdDiff(packet, sendobj);
+    }
+    
+    NET_SendPacket(server_addr, packet);
+    NET_FreePacket(packet);
+}
+
+void NET_CL_SendTiccmd(ticcmd_t *ticcmd, int maketic)
+{
+    net_send_queue_t *sendobj;
+    unsigned int diff = 0;
+    int starttic, endtic;
+    
+    if (!net_client_connected || client_state != CLIENT_STATE_IN_GAME)
+        return;
+    
+    // Calculate diff from last command
+    if (ticcmd->forwardmove != last_ticcmd.forwardmove)
+        diff |= NET_TICDIFF_FORWARD;
+    if (ticcmd->sidemove != last_ticcmd.sidemove)
+        diff |= NET_TICDIFF_SIDE;
+    if (ticcmd->angleturn != last_ticcmd.angleturn)
+        diff |= NET_TICDIFF_TURN;
+    if (ticcmd->buttons != last_ticcmd.buttons)
+        diff |= NET_TICDIFF_BUTTONS;
+    // ALWAYS include consistency - critical for game sync!
+    diff |= NET_TICDIFF_CONSISTANCY;
+    
+    // Store in send queue
+    sendobj = &send_queue[maketic % BACKUPTICS];
+    sendobj->active = true;
+    sendobj->seq = maketic;
+    sendobj->time = I_GetTimeMS();
+    sendobj->diff = diff;
+    sendobj->cmd = *ticcmd;
+    
+    // Update last ticcmd for future diffs
+    last_ticcmd = *ticcmd;
+    
+    // Send just the current tic for now (simpler - avoid extratics complexity)
+    starttic = maketic;
+    endtic = maketic;
+    
+    NET_CL_SendTics(starttic, endtic);
+}
+
+boolean NET_CL_GetSettings(net_gamesettings_t *settings)
+{
+    if (!received_settings_valid)
+        return false;
+
+    memcpy(settings, &received_settings, sizeof(net_gamesettings_t));
+    return true;
+}
+
+void NET_Init(void)
+{
+    NET_CL_Init();
+}
+
+void NET_BindVariables(void)
+{
+    // Could bind config variables here
+}
+
+// External lobby functions (from net_lobby.c and doomgeneric_linuxvt.c)
+extern void DG_DrawLobby(int num_players, int max_players, int is_controller,
+                         const char player_names[NET_MAXPLAYERS][MAXPLAYERNAME],
+                         const char player_addrs[NET_MAXPLAYERS][MAXPLAYERNAME],
+                         int consoleplayer);
+extern int DG_CheckLobbyInput(void);  // Returns 1=start, -1=quit, 0=nothing
+
+// NET_WaitForLaunch - Wait for LAUNCH signal in the lobby
+// Does NOT send GAMESTART - that happens in D_StartNetGame
+void NET_WaitForLaunch(void)
+{
+    int last_num_players = -1;
+    int lobby_update_timer = 0;
+    int input;
+    
+    net_waiting_for_launch = true;
+
+    fprintf(stderr, "NET_WaitForLaunch: Waiting for game launch...\n");
+
+    while (net_waiting_for_launch && net_client_connected)
+    {
+        NET_CL_Run();
+        
+        // Update lobby display periodically or when player count changes
+        if (net_client_received_wait_data) {
+            if (net_client_wait_data.num_players != last_num_players || lobby_update_timer <= 0) {
+                DG_DrawLobby(net_client_wait_data.num_players,
+                            net_client_wait_data.max_players,
+                            net_client_wait_data.is_controller,
+                            net_client_wait_data.player_names,
+                            net_client_wait_data.player_addrs,
+                            net_client_wait_data.consoleplayer);
+                last_num_players = net_client_wait_data.num_players;
+                lobby_update_timer = 20;  // Update every ~1 second
+            }
+            lobby_update_timer--;
+            
+            // Check for input
+            input = DG_CheckLobbyInput();
+            if (input == -1) {
+                // User pressed quit (Red button)
+                fprintf(stderr, "NET_WaitForLaunch: User quit from lobby\n");
+                net_client_connected = false;
+                return;
+            }
+            else if (input == 1 && net_client_wait_data.is_controller) {
+                // Controller pressed start (Green button)
+                fprintf(stderr, "NET_WaitForLaunch: Controller starting game!\n");
+                NET_CL_LaunchGame();
+            }
+        }
+        
+        I_Sleep(50);
+    }
+    
+    fprintf(stderr, "NET_WaitForLaunch: Got LAUNCH signal, returning to game init...\n");
+}
+
+// NET_CL_SendStartAndWait - Send GAMESTART and wait for server response
+// Called from D_StartNetGame after NET_WaitForLaunch returns
+void NET_CL_SendStartAndWait(net_gamesettings_t *settings)
+{
+    int timeout;
+    
+    if (!net_client_connected) {
+        fprintf(stderr, "NET_CL_SendStartAndWait: Not connected!\n");
+        return;
+    }
+    
+    fprintf(stderr, "NET_CL_SendStartAndWait: Sending GAMESTART request...\n");
+    
+    NET_CL_StartGame(settings);
+    
+    fprintf(stderr, "NET_CL_SendStartAndWait: Waiting for GAMESTART response...\n");
+    
+    // Wait for GAMESTART response with final settings from server
+    timeout = 0;
+    while (!received_settings_valid && net_client_connected && timeout < 200)
+    {
+        NET_CL_Run();
+        I_Sleep(50);
+        timeout++;
+    }
+    
+    fprintf(stderr, "NET_CL_SendStartAndWait: Done! settings_valid=%d connected=%d timeout=%d\n", 
+            received_settings_valid, net_client_connected, timeout);
+}
+
+net_addr_t *NET_FindLANServer(void)
+{
+    // LAN discovery not implemented
+    return NULL;
+}
+
+
+
diff --git a/doomgeneric/net_dedicated.c b/doomgeneric/net_dedicated.c
new file mode 100644
index 0000000..e66911b
--- /dev/null
+++ b/doomgeneric/net_dedicated.c
@@ -0,0 +1,19 @@
+//
+// Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Dedicated server mode - stub
+//
+
+#include <stdio.h>
+
+#include "i_system.h"
+#include "net_dedicated.h"
+
+void NET_DedicatedServer(void)
+{
+    I_Error("Dedicated server mode not implemented");
+}
+
+
+
diff --git a/doomgeneric/net_defs.h b/doomgeneric/net_defs.h
index bedfb95..f1ab16e 100644
--- a/doomgeneric/net_defs.h
+++ b/doomgeneric/net_defs.h
@@ -100,7 +100,9 @@ struct _net_addr_s
 
 // magic number sent when connecting to check this is a valid client
 
-#define NET_MAGIC_NUMBER 3436803284U
+// Magic number changed in Chocolate Doom 3.1.0
+#define NET_MAGIC_NUMBER     1454104972U
+#define NET_OLD_MAGIC_NUMBER 3436803284U
 
 // header field value indicating that the packet is a reliable packet
 
diff --git a/doomgeneric/net_io.c b/doomgeneric/net_io.c
new file mode 100644
index 0000000..f531025
--- /dev/null
+++ b/doomgeneric/net_io.c
@@ -0,0 +1,112 @@
+//
+// Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Network I/O layer - manages network contexts and modules
+//
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "net_io.h"
+#include "net_packet.h"
+
+#define MAX_MODULES 16
+
+struct _net_context_s
+{
+    net_module_t *modules[MAX_MODULES];
+    int num_modules;
+};
+
+// Broadcast address placeholder
+net_addr_t net_broadcast_addr;
+
+net_context_t *NET_NewContext(void)
+{
+    net_context_t *context;
+
+    context = malloc(sizeof(net_context_t));
+    if (context == NULL)
+        return NULL;
+
+    context->num_modules = 0;
+    return context;
+}
+
+void NET_AddModule(net_context_t *context, net_module_t *module)
+{
+    if (context->num_modules >= MAX_MODULES)
+        return;
+
+    context->modules[context->num_modules] = module;
+    context->num_modules++;
+}
+
+void NET_SendPacket(net_addr_t *addr, net_packet_t *packet)
+{
+    if (addr == NULL || addr->module == NULL)
+        return;
+
+    addr->module->SendPacket(addr, packet);
+}
+
+void NET_SendBroadcast(net_context_t *context, net_packet_t *packet)
+{
+    // For now, broadcast is not implemented
+    // Would need to send to 255.255.255.255 on each module
+}
+
+boolean NET_RecvPacket(net_context_t *context, net_addr_t **addr,
+                       net_packet_t **packet)
+{
+    int i;
+
+    for (i = 0; i < context->num_modules; i++)
+    {
+        if (context->modules[i]->RecvPacket(addr, packet))
+            return true;
+    }
+
+    return false;
+}
+
+char *NET_AddrToString(net_addr_t *addr)
+{
+    static char buffer[128];
+
+    if (addr == NULL || addr->module == NULL)
+    {
+        strcpy(buffer, "(null)");
+        return buffer;
+    }
+
+    addr->module->AddrToString(addr, buffer, sizeof(buffer));
+    return buffer;
+}
+
+void NET_FreeAddress(net_addr_t *addr)
+{
+    if (addr == NULL || addr->module == NULL)
+        return;
+
+    addr->module->FreeAddress(addr);
+}
+
+net_addr_t *NET_ResolveAddress(net_context_t *context, char *address)
+{
+    net_addr_t *result;
+    int i;
+
+    for (i = 0; i < context->num_modules; i++)
+    {
+        result = context->modules[i]->ResolveAddress(address);
+        if (result != NULL)
+            return result;
+    }
+
+    return NULL;
+}
+
+
+
diff --git a/doomgeneric/net_lobby.c b/doomgeneric/net_lobby.c
new file mode 100644
index 0000000..832f4cd
--- /dev/null
+++ b/doomgeneric/net_lobby.c
@@ -0,0 +1,335 @@
+//
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Simple lobby screen for multiplayer waiting room
+//
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/fb.h>
+
+#include "doomtype.h"
+#include "net_defs.h"
+
+// Embedded 8x8 font (basic ASCII 32-127)
+// Simple monospace bitmap font for lobby text
+static const unsigned char font8x8[][8] = {
+    // Space (32)
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+    // ! (33)
+    {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00},
+    // " (34)
+    {0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},
+    // # (35)
+    {0x6C, 0xFE, 0x6C, 0x6C, 0xFE, 0x6C, 0x00, 0x00},
+    // $ (36)
+    {0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00},
+    // % (37)
+    {0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, 0x00},
+    // & (38)
+    {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00},
+    // ' (39)
+    {0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},
+    // ( (40)
+    {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00},
+    // ) (41)
+    {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00},
+    // * (42)
+    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},
+    // + (43)
+    {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00},
+    // , (44)
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30},
+    // - (45)
+    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00},
+    // . (46)
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
+    // / (47)
+    {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x00, 0x00},
+    // 0 (48)
+    {0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00},
+    // 1 (49)
+    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00},
+    // 2 (50)
+    {0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00},
+    // 3 (51)
+    {0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00},
+    // 4 (52)
+    {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00},
+    // 5 (53)
+    {0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00},
+    // 6 (54)
+    {0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00},
+    // 7 (55)
+    {0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00},
+    // 8 (56)
+    {0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00},
+    // 9 (57)
+    {0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00},
+    // : (58)
+    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00},
+    // ; (59)
+    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30},
+    // < (60)
+    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},
+    // = (61)
+    {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00},
+    // > (62)
+    {0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00},
+    // ? (63)
+    {0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00},
+    // @ (64)
+    {0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00},
+    // A-Z (65-90)
+    {0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // A
+    {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00}, // B
+    {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00}, // C
+    {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00}, // D
+    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00}, // E
+    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00}, // F
+    {0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00}, // G
+    {0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // H
+    {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // I
+    {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00}, // J
+    {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00}, // K
+    {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00}, // L
+    {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00}, // M
+    {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00}, // N
+    {0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // O
+    {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}, // P
+    {0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06}, // Q
+    {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00}, // R
+    {0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00}, // S
+    {0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // T
+    {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // U
+    {0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00}, // V
+    {0xC6, 0xC6, 0xD6, 0xFE, 0xFE, 0xEE, 0xC6, 0x00}, // W
+    {0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00}, // X
+    {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00}, // Y
+    {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00}, // Z
+    // [ (91)
+    {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00},
+    // \ (92)
+    {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00},
+    // ] (93)
+    {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00},
+    // ^ (94)
+    {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00},
+    // _ (95)
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
+    // ` (96)
+    {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00},
+    // a-z (97-122) - lowercase
+    {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00}, // a
+    {0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00}, // b
+    {0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00}, // c
+    {0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // d
+    {0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00}, // e
+    {0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00}, // f
+    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x78}, // g
+    {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00}, // h
+    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, // i
+    {0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C}, // j
+    {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00}, // k
+    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // l
+    {0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00}, // m
+    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
+    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // o
+    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0}, // p
+    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E}, // q
+    {0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00}, // r
+    {0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00}, // s
+    {0x30, 0x30, 0xFC, 0x30, 0x30, 0x36, 0x1C, 0x00}, // t
+    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // u
+    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // v
+    {0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00}, // w
+    {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00}, // x
+    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C}, // y
+    {0x00, 0x00, 0xFE, 0x8C, 0x18, 0x32, 0xFE, 0x00}, // z
+};
+
+// Framebuffer access (defined in doomgeneric_linuxvt.c)
+extern int fbFd;
+extern unsigned int fbWidth, fbHeight;
+extern uint16_t *renderBuffer;
+extern size_t renderBufferSize;
+
+// Virtual screen dimensions after 90° CCW rotation
+// Physical: 222x480, Virtual (for content): 480x222
+#define LOBBY_WIDTH  480
+#define LOBBY_HEIGHT 222
+
+// RGB565 color definitions
+#define RGB565_BLACK    0x0000
+#define RGB565_WHITE    0xFFFF
+#define RGB565_RED      0xF800
+#define RGB565_GREEN    0x07E0
+#define RGB565_BLUE     0x001F
+#define RGB565_YELLOW   0xFFE0
+#define RGB565_CYAN     0x07FF
+#define RGB565_MAGENTA  0xF81F
+#define RGB565_ORANGE   0xFD20
+#define RGB565_DOOM_RED 0xA800  // Dark red for DOOM theme
+
+// Set a pixel with 90° CW rotation (to match game orientation)
+// Virtual (x,y) in 480x222 space -> Physical in 222x480 framebuffer
+static inline void lobby_set_pixel(int vx, int vy, uint16_t color)
+{
+    // 90° CW rotation: (vx, vy) -> (LOBBY_HEIGHT-1-vy, vx)
+    int px = LOBBY_HEIGHT - 1 - vy;
+    int py = vx;
+    
+    if (px >= 0 && px < (int)fbWidth && py >= 0 && py < (int)fbHeight) {
+        renderBuffer[py * fbWidth + px] = color;
+    }
+}
+
+// Draw a single character at virtual (x,y)
+static void lobby_draw_char(int x, int y, char c, uint16_t color)
+{
+    if (c < 32 || c > 122) c = '?';
+    int idx = c - 32;
+    if (idx < 0 || idx >= (int)(sizeof(font8x8)/sizeof(font8x8[0])))
+        return;
+    
+    const unsigned char *glyph = font8x8[idx];
+    
+    // Draw each pixel of the 8x8 glyph
+    for (int gy = 0; gy < 8; gy++) {
+        unsigned char row = glyph[gy];
+        for (int gx = 0; gx < 8; gx++) {
+            if (row & (0x80 >> gx)) {
+                lobby_set_pixel(x + gx, y + gy, color);
+            }
+        }
+    }
+}
+
+// Draw a string at virtual (x,y)
+static void lobby_draw_string(int x, int y, const char *str, uint16_t color)
+{
+    while (*str) {
+        lobby_draw_char(x, y, *str, color);
+        x += 8;  // 8 pixels per character
+        str++;
+    }
+}
+
+// Draw a centered string (centered in virtual 480-wide space)
+static void lobby_draw_centered(int y, const char *str, uint16_t color)
+{
+    int len = strlen(str);
+    int x = (LOBBY_WIDTH - len * 8) / 2;
+    lobby_draw_string(x, y, str, color);
+}
+
+// Draw a filled rectangle in virtual coordinates
+static void lobby_fill_rect(int x, int y, int w, int h, uint16_t color)
+{
+    for (int vy = y; vy < y + h && vy < LOBBY_HEIGHT; vy++) {
+        for (int vx = x; vx < x + w && vx < LOBBY_WIDTH; vx++) {
+            if (vx >= 0 && vy >= 0) {
+                lobby_set_pixel(vx, vy, color);
+            }
+        }
+    }
+}
+
+// Clear the screen
+static void lobby_clear(uint16_t color)
+{
+    for (size_t i = 0; i < fbWidth * fbHeight; i++) {
+        renderBuffer[i] = color;
+    }
+}
+
+// Flush the render buffer to screen
+static void lobby_flush(void)
+{
+    if (fbFd >= 0 && renderBuffer) {
+        lseek(fbFd, 0, SEEK_SET);
+        write(fbFd, renderBuffer, renderBufferSize);
+    }
+}
+
+// Main lobby drawing function - called from NET_WaitForLaunch
+// Uses virtual 480x222 coordinate system (rotated 90° CW to physical 222x480)
+void DG_DrawLobby(int num_players, int max_players, int is_controller, 
+                  const char player_names[NET_MAXPLAYERS][MAXPLAYERNAME],
+                  const char player_addrs[NET_MAXPLAYERS][MAXPLAYERNAME],
+                  int consoleplayer)
+{
+    char buf[80];
+    int y = 15;
+    
+    // Clear to dark background
+    lobby_clear(0x1082);  // Dark gray-blue
+    
+    // Title with red accent box (full width of virtual screen)
+    lobby_fill_rect(0, 5, LOBBY_WIDTH, 35, RGB565_DOOM_RED);
+    lobby_draw_centered(10, "DOOM DEATHMATCH", RGB565_WHITE);
+    lobby_draw_centered(22, "MULTIPLAYER LOBBY", RGB565_YELLOW);
+    
+    y = 50;
+    
+    // Player count
+    snprintf(buf, sizeof(buf), "Players: %d / %d", num_players, max_players);
+    lobby_draw_centered(y, buf, RGB565_WHITE);
+    y += 16;
+    
+    // Separator line
+    lobby_fill_rect(50, y, LOBBY_WIDTH - 100, 2, RGB565_CYAN);
+    y += 10;
+    
+    // Player list with names and addresses
+    for (int i = 0; i < num_players && i < max_players; i++) {
+        uint16_t color = (i == consoleplayer) ? RGB565_YELLOW : RGB565_GREEN;
+        const char *name = player_names[i][0] ? player_names[i] : "Player";
+        const char *addr = player_addrs[i][0] ? player_addrs[i] : "";
+        
+        // Show player number, name, and marker if it's us
+        if (i == consoleplayer) {
+            snprintf(buf, sizeof(buf), "%d. %s (YOU)", i + 1, name);
+        } else {
+            snprintf(buf, sizeof(buf), "%d. %s", i + 1, name);
+        }
+        lobby_draw_string(40, y, buf, color);
+        y += 12;
+        
+        // Show address on second line (smaller indent)
+        if (addr[0]) {
+            snprintf(buf, sizeof(buf), "   %s", addr);
+            lobby_draw_string(40, y, buf, 0x8410);  // Dim gray
+        }
+        y += 14;
+    }
+    
+    // Empty slots
+    for (int i = num_players; i < max_players; i++) {
+        snprintf(buf, sizeof(buf), "%d. (waiting...)", i + 1);
+        lobby_draw_string(40, y, buf, 0x4208);  // Gray
+        y += 26;  // Same spacing as filled slots
+    }
+    
+    // Instructions at bottom
+    y = LOBBY_HEIGHT - 50;
+    
+    if (is_controller) {
+        lobby_draw_centered(y, "GREEN = START GAME", RGB565_GREEN);
+        y += 14;
+    } else {
+        lobby_draw_centered(y, "Waiting for host...", RGB565_YELLOW);
+        y += 14;
+    }
+    lobby_draw_centered(y, "RED = QUIT", RGB565_RED);
+    
+    // Flush to screen
+    lobby_flush();
+}
+
+// DG_CheckLobbyInput is defined in doomgeneric_linuxvt.c
+// (has access to input file descriptors)
+
diff --git a/doomgeneric/net_loop.c b/doomgeneric/net_loop.c
new file mode 100644
index 0000000..368e45c
--- /dev/null
+++ b/doomgeneric/net_loop.c
@@ -0,0 +1,192 @@
+//
+// Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Loopback network module - for local server in same process
+//
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "doomtype.h"
+#include "net_defs.h"
+#include "net_loop.h"
+#include "net_packet.h"
+
+#define MAX_QUEUE_SIZE 16
+
+typedef struct
+{
+    net_packet_t *packets[MAX_QUEUE_SIZE];
+    int head;
+    int tail;
+} packet_queue_t;
+
+static packet_queue_t client_queue;
+static packet_queue_t server_queue;
+static boolean client_initialized = false;
+static boolean server_initialized = false;
+
+// Loopback address
+static net_addr_t loopback_addr;
+
+static void QueueInit(packet_queue_t *queue)
+{
+    queue->head = 0;
+    queue->tail = 0;
+}
+
+static void QueuePush(packet_queue_t *queue, net_packet_t *packet)
+{
+    int next = (queue->head + 1) % MAX_QUEUE_SIZE;
+
+    if (next == queue->tail)
+    {
+        // Queue full, drop oldest
+        NET_FreePacket(queue->packets[queue->tail]);
+        queue->tail = (queue->tail + 1) % MAX_QUEUE_SIZE;
+    }
+
+    queue->packets[queue->head] = NET_PacketDup(packet);
+    queue->head = next;
+}
+
+static net_packet_t *QueuePop(packet_queue_t *queue)
+{
+    net_packet_t *packet;
+
+    if (queue->head == queue->tail)
+        return NULL;
+
+    packet = queue->packets[queue->tail];
+    queue->tail = (queue->tail + 1) % MAX_QUEUE_SIZE;
+
+    return packet;
+}
+
+// Client module functions
+
+static boolean NET_Loop_Client_InitClient(void)
+{
+    QueueInit(&client_queue);
+    client_initialized = true;
+    return true;
+}
+
+static boolean NET_Loop_Client_InitServer(void)
+{
+    return false;  // Client module can't be server
+}
+
+static void NET_Loop_Client_SendPacket(net_addr_t *addr, net_packet_t *packet)
+{
+    if (server_initialized)
+    {
+        QueuePush(&server_queue, packet);
+    }
+}
+
+static boolean NET_Loop_Client_RecvPacket(net_addr_t **addr, net_packet_t **packet)
+{
+    *packet = QueuePop(&client_queue);
+
+    if (*packet == NULL)
+        return false;
+
+    *addr = &loopback_addr;
+    return true;
+}
+
+static void NET_Loop_Client_AddrToString(net_addr_t *addr, char *buffer, int buffer_len)
+{
+    snprintf(buffer, buffer_len, "loopback");
+}
+
+static void NET_Loop_Client_FreeAddress(net_addr_t *addr)
+{
+    // Loopback address is static
+}
+
+static net_addr_t *NET_Loop_Client_ResolveAddress(char *addr)
+{
+    if (addr == NULL)
+    {
+        loopback_addr.module = &net_loop_client_module;
+        loopback_addr.handle = NULL;
+        return &loopback_addr;
+    }
+    return NULL;
+}
+
+// Server module functions
+
+static boolean NET_Loop_Server_InitClient(void)
+{
+    return false;  // Server module can't be client
+}
+
+static boolean NET_Loop_Server_InitServer(void)
+{
+    QueueInit(&server_queue);
+    server_initialized = true;
+    return true;
+}
+
+static void NET_Loop_Server_SendPacket(net_addr_t *addr, net_packet_t *packet)
+{
+    if (client_initialized)
+    {
+        QueuePush(&client_queue, packet);
+    }
+}
+
+static boolean NET_Loop_Server_RecvPacket(net_addr_t **addr, net_packet_t **packet)
+{
+    *packet = QueuePop(&server_queue);
+
+    if (*packet == NULL)
+        return false;
+
+    *addr = &loopback_addr;
+    return true;
+}
+
+static void NET_Loop_Server_AddrToString(net_addr_t *addr, char *buffer, int buffer_len)
+{
+    snprintf(buffer, buffer_len, "loopback");
+}
+
+static void NET_Loop_Server_FreeAddress(net_addr_t *addr)
+{
+    // Loopback address is static
+}
+
+static net_addr_t *NET_Loop_Server_ResolveAddress(char *addr)
+{
+    return NULL;
+}
+
+net_module_t net_loop_client_module =
+{
+    NET_Loop_Client_InitClient,
+    NET_Loop_Client_InitServer,
+    NET_Loop_Client_SendPacket,
+    NET_Loop_Client_RecvPacket,
+    NET_Loop_Client_AddrToString,
+    NET_Loop_Client_FreeAddress,
+    NET_Loop_Client_ResolveAddress,
+};
+
+net_module_t net_loop_server_module =
+{
+    NET_Loop_Server_InitClient,
+    NET_Loop_Server_InitServer,
+    NET_Loop_Server_SendPacket,
+    NET_Loop_Server_RecvPacket,
+    NET_Loop_Server_AddrToString,
+    NET_Loop_Server_FreeAddress,
+    NET_Loop_Server_ResolveAddress,
+};
+
+
+
diff --git a/doomgeneric/net_packet.c b/doomgeneric/net_packet.c
new file mode 100644
index 0000000..a274cb2
--- /dev/null
+++ b/doomgeneric/net_packet.c
@@ -0,0 +1,203 @@
+//
+// Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Network packet buffer management
+//
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "net_packet.h"
+
+net_packet_t *NET_NewPacket(int initial_size)
+{
+    net_packet_t *packet;
+
+    packet = malloc(sizeof(net_packet_t));
+    if (packet == NULL)
+        return NULL;
+
+    packet->alloced = initial_size;
+    packet->data = malloc(initial_size);
+    if (packet->data == NULL)
+    {
+        free(packet);
+        return NULL;
+    }
+
+    packet->len = 0;
+    packet->pos = 0;
+
+    return packet;
+}
+
+net_packet_t *NET_PacketDup(net_packet_t *packet)
+{
+    net_packet_t *newpacket;
+
+    newpacket = NET_NewPacket(packet->len);
+    if (newpacket == NULL)
+        return NULL;
+
+    memcpy(newpacket->data, packet->data, packet->len);
+    newpacket->len = packet->len;
+
+    return newpacket;
+}
+
+void NET_FreePacket(net_packet_t *packet)
+{
+    free(packet->data);
+    free(packet);
+}
+
+// Ensure packet has enough space for 'size' more bytes
+static boolean NET_EnsureSpace(net_packet_t *packet, size_t size)
+{
+    size_t newsize;
+    byte *newdata;
+
+    if (packet->len + size <= packet->alloced)
+        return true;
+
+    // Need to grow the buffer
+    newsize = packet->alloced * 2;
+    while (newsize < packet->len + size)
+        newsize *= 2;
+
+    newdata = realloc(packet->data, newsize);
+    if (newdata == NULL)
+        return false;
+
+    packet->data = newdata;
+    packet->alloced = newsize;
+    return true;
+}
+
+// Read functions
+boolean NET_ReadInt8(net_packet_t *packet, unsigned int *data)
+{
+    if (packet->pos + 1 > packet->len)
+        return false;
+
+    *data = packet->data[packet->pos];
+    packet->pos += 1;
+    return true;
+}
+
+boolean NET_ReadInt16(net_packet_t *packet, unsigned int *data)
+{
+    if (packet->pos + 2 > packet->len)
+        return false;
+
+    // Big-endian (network byte order) - high byte first
+    *data = (packet->data[packet->pos] << 8)
+          | packet->data[packet->pos + 1];
+    packet->pos += 2;
+    return true;
+}
+
+boolean NET_ReadInt32(net_packet_t *packet, unsigned int *data)
+{
+    if (packet->pos + 4 > packet->len)
+        return false;
+
+    // Big-endian (network byte order) - highest byte first
+    *data = (packet->data[packet->pos] << 24)
+          | (packet->data[packet->pos + 1] << 16)
+          | (packet->data[packet->pos + 2] << 8)
+          | packet->data[packet->pos + 3];
+    packet->pos += 4;
+    return true;
+}
+
+boolean NET_ReadSInt8(net_packet_t *packet, signed int *data)
+{
+    unsigned int udata;
+    if (!NET_ReadInt8(packet, &udata))
+        return false;
+    *data = (signed char)udata;
+    return true;
+}
+
+boolean NET_ReadSInt16(net_packet_t *packet, signed int *data)
+{
+    unsigned int udata;
+    if (!NET_ReadInt16(packet, &udata))
+        return false;
+    *data = (signed short)udata;
+    return true;
+}
+
+boolean NET_ReadSInt32(net_packet_t *packet, signed int *data)
+{
+    if (!NET_ReadInt32(packet, (unsigned int *)data))
+        return false;
+    return true;
+}
+
+char *NET_ReadString(net_packet_t *packet)
+{
+    char *start;
+
+    start = (char *)packet->data + packet->pos;
+
+    // Search for NUL terminator
+    while (packet->pos < packet->len && packet->data[packet->pos] != '\0')
+        packet->pos++;
+
+    if (packet->pos >= packet->len)
+        return NULL;  // No terminator found
+
+    packet->pos++;  // Skip the NUL
+    return start;
+}
+
+// Write functions
+void NET_WriteInt8(net_packet_t *packet, unsigned int i)
+{
+    if (!NET_EnsureSpace(packet, 1))
+        return;
+
+    packet->data[packet->len] = i & 0xff;
+    packet->len += 1;
+}
+
+void NET_WriteInt16(net_packet_t *packet, unsigned int i)
+{
+    if (!NET_EnsureSpace(packet, 2))
+        return;
+
+    // Big-endian (network byte order) - high byte first
+    packet->data[packet->len] = (i >> 8) & 0xff;
+    packet->data[packet->len + 1] = i & 0xff;
+    packet->len += 2;
+}
+
+void NET_WriteInt32(net_packet_t *packet, unsigned int i)
+{
+    if (!NET_EnsureSpace(packet, 4))
+        return;
+
+    // Big-endian (network byte order) - highest byte first
+    packet->data[packet->len] = (i >> 24) & 0xff;
+    packet->data[packet->len + 1] = (i >> 16) & 0xff;
+    packet->data[packet->len + 2] = (i >> 8) & 0xff;
+    packet->data[packet->len + 3] = i & 0xff;
+    packet->len += 4;
+}
+
+void NET_WriteString(net_packet_t *packet, char *string)
+{
+    size_t len = strlen(string) + 1;
+
+    if (!NET_EnsureSpace(packet, len))
+        return;
+
+    memcpy(packet->data + packet->len, string, len);
+    packet->len += len;
+}
+
+
+
diff --git a/doomgeneric/net_query.c b/doomgeneric/net_query.c
new file mode 100644
index 0000000..8c85204
--- /dev/null
+++ b/doomgeneric/net_query.c
@@ -0,0 +1,29 @@
+//
+// Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Server query functions - stubs for client-only mode
+//
+
+#include <stdio.h>
+
+#include "doomtype.h"
+#include "net_query.h"
+
+void NET_QueryAddress(char *addr)
+{
+    printf("Server query not implemented\n");
+}
+
+void NET_LANQuery(void)
+{
+    printf("LAN query not implemented\n");
+}
+
+void NET_MasterQuery(void)
+{
+    printf("Master server query not implemented\n");
+}
+
+
+
diff --git a/doomgeneric/net_query.h b/doomgeneric/net_query.h
index 563a055..1624d63 100644
--- a/doomgeneric/net_query.h
+++ b/doomgeneric/net_query.h
@@ -1,44 +1,15 @@
 //
 // Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
 //
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// DESCRIPTION:
-//     Querying servers to find their current status.
+// Server query functions
 //
 
 #ifndef NET_QUERY_H
 #define NET_QUERY_H
 
-#include "net_defs.h"
-
-typedef void (*net_query_callback_t)(net_addr_t *addr,
-                                     net_querydata_t *querydata,
-                                     unsigned int ping_time,
-                                     void *user_data);
-
-extern int NET_StartLANQuery(void);
-extern int NET_StartMasterQuery(void);
-
-extern void NET_LANQuery(void);
-extern void NET_MasterQuery(void);
-extern void NET_QueryAddress(char *addr);
-extern net_addr_t *NET_FindLANServer(void);
-
-extern int NET_Query_Poll(net_query_callback_t callback, void *user_data);
-
-extern net_addr_t *NET_Query_ResolveMaster(net_context_t *context);
-extern void NET_Query_AddToMaster(net_addr_t *master_addr);
-extern boolean NET_Query_CheckAddedToMaster(boolean *result);
-extern void NET_Query_MasterResponse(net_packet_t *packet);
+void NET_QueryAddress(char *addr);
+void NET_LANQuery(void);
+void NET_MasterQuery(void);
 
 #endif /* #ifndef NET_QUERY_H */
-
diff --git a/doomgeneric/net_server.c b/doomgeneric/net_server.c
new file mode 100644
index 0000000..4a23397
--- /dev/null
+++ b/doomgeneric/net_server.c
@@ -0,0 +1,54 @@
+//
+// Copyright(C) 2005-2014 Simon Howard
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// Network server code - minimal implementation for client-only mode
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "doomtype.h"
+#include "net_defs.h"
+#include "net_server.h"
+
+static net_module_t *server_modules[16];
+static int num_server_modules = 0;
+static boolean server_initialized = false;
+
+void NET_SV_Init(void)
+{
+    if (server_initialized)
+        return;
+
+    printf("NET_SV_Init: Server mode not fully implemented\n");
+    server_initialized = true;
+}
+
+void NET_SV_Run(void)
+{
+    // Server tick - not implemented for client-only mode
+}
+
+void NET_SV_Shutdown(void)
+{
+    server_initialized = false;
+}
+
+void NET_SV_AddModule(net_module_t *module)
+{
+    if (num_server_modules >= 16)
+        return;
+
+    server_modules[num_server_modules++] = module;
+}
+
+void NET_SV_RegisterWithMaster(void)
+{
+    // Master server registration - not implemented
+    printf("NET_SV_RegisterWithMaster: Not implemented\n");
+}
+
+
+
diff --git a/doomgeneric/net_socket.c b/doomgeneric/net_socket.c
new file mode 100644
index 0000000..ab6b8ac
--- /dev/null
+++ b/doomgeneric/net_socket.c
@@ -0,0 +1,298 @@
+//
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// POSIX socket-based network module (replaces SDL_net)
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include "doomtype.h"
+#include "net_defs.h"
+#include "net_packet.h"
+#include "net_socket.h"
+
+#define DEFAULT_PORT 2342  // Chocolate Doom default port
+
+// Socket address wrapper
+typedef struct
+{
+    struct sockaddr_in addr;
+    int refcount;
+} socket_addr_t;
+
+static int client_socket = -1;
+static int server_socket = -1;
+
+// Set socket to non-blocking mode
+static boolean SetNonBlocking(int sock)
+{
+    int flags = fcntl(sock, F_GETFL, 0);
+    if (flags < 0)
+        return false;
+    return fcntl(sock, F_SETFL, flags | O_NONBLOCK) >= 0;
+}
+
+static boolean NET_Socket_InitClient(void)
+{
+    client_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (client_socket < 0)
+    {
+        fprintf(stderr, "NET_Socket_InitClient: Failed to create socket\n");
+        return false;
+    }
+
+    if (!SetNonBlocking(client_socket))
+    {
+        fprintf(stderr, "NET_Socket_InitClient: Failed to set non-blocking\n");
+        close(client_socket);
+        client_socket = -1;
+        return false;
+    }
+
+    return true;
+}
+
+static boolean NET_Socket_InitServer(void)
+{
+    struct sockaddr_in addr;
+
+    server_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (server_socket < 0)
+    {
+        fprintf(stderr, "NET_Socket_InitServer: Failed to create socket\n");
+        return false;
+    }
+
+    // Allow address reuse
+    int opt = 1;
+    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
+
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = INADDR_ANY;
+    addr.sin_port = htons(DEFAULT_PORT);
+
+    if (bind(server_socket, (struct sockaddr *)&addr, sizeof(addr)) < 0)
+    {
+        fprintf(stderr, "NET_Socket_InitServer: Failed to bind to port %d\n", DEFAULT_PORT);
+        close(server_socket);
+        server_socket = -1;
+        return false;
+    }
+
+    if (!SetNonBlocking(server_socket))
+    {
+        fprintf(stderr, "NET_Socket_InitServer: Failed to set non-blocking\n");
+        close(server_socket);
+        server_socket = -1;
+        return false;
+    }
+
+    return true;
+}
+
+static void NET_Socket_SendPacket(net_addr_t *addr, net_packet_t *packet)
+{
+    socket_addr_t *sockaddr;
+    int sock;
+    ssize_t result;
+
+    sockaddr = (socket_addr_t *)addr->handle;
+
+    // Use server socket if available, otherwise client socket
+    sock = (server_socket >= 0) ? server_socket : client_socket;
+    if (sock < 0)
+    {
+        fprintf(stderr, "NET_Socket_SendPacket: No socket available\n");
+        return;
+    }
+
+    result = sendto(sock, packet->data, packet->len, 0,
+           (struct sockaddr *)&sockaddr->addr, sizeof(sockaddr->addr));
+    
+    (void)result;  // Suppress unused warning - logging removed for performance
+}
+
+static boolean NET_Socket_RecvPacket(net_addr_t **addr, net_packet_t **packet)
+{
+    struct sockaddr_in from_addr;
+    socklen_t from_len = sizeof(from_addr);
+    ssize_t len;
+    int sock;
+    byte buffer[2048];
+    socket_addr_t *sockaddr;
+    net_addr_t *netaddr;
+
+    // Use server socket if available, otherwise client socket
+    sock = (server_socket >= 0) ? server_socket : client_socket;
+    if (sock < 0)
+    {
+        fprintf(stderr, "NET_Socket_RecvPacket: No socket (server=%d, client=%d)\n",
+                server_socket, client_socket);
+        return false;
+    }
+
+    len = recvfrom(sock, buffer, sizeof(buffer), 0,
+                   (struct sockaddr *)&from_addr, &from_len);
+
+    if (len < 0)
+    {
+        // No data available (would block)
+        if (errno == EAGAIN || errno == EWOULDBLOCK)
+            return false;
+        fprintf(stderr, "NET_Socket_RecvPacket: recvfrom error: %s\n", strerror(errno));
+        return false;
+    }
+
+    if (len == 0)
+        return false;
+
+    // Create packet
+    *packet = NET_NewPacket(len);
+    if (*packet == NULL)
+        return false;
+
+    memcpy((*packet)->data, buffer, len);
+    (*packet)->len = len;
+
+    // Create address
+    sockaddr = malloc(sizeof(socket_addr_t));
+    if (sockaddr == NULL)
+    {
+        NET_FreePacket(*packet);
+        return false;
+    }
+
+    memcpy(&sockaddr->addr, &from_addr, sizeof(from_addr));
+    sockaddr->refcount = 1;
+
+    netaddr = malloc(sizeof(net_addr_t));
+    if (netaddr == NULL)
+    {
+        free(sockaddr);
+        NET_FreePacket(*packet);
+        return false;
+    }
+
+    netaddr->module = &net_socket_module;
+    netaddr->handle = sockaddr;
+    *addr = netaddr;
+
+    return true;
+}
+
+static void NET_Socket_AddrToString(net_addr_t *addr, char *buffer, int buffer_len)
+{
+    socket_addr_t *sockaddr = (socket_addr_t *)addr->handle;
+
+    snprintf(buffer, buffer_len, "%s:%d",
+             inet_ntoa(sockaddr->addr.sin_addr),
+             ntohs(sockaddr->addr.sin_port));
+}
+
+static void NET_Socket_FreeAddress(net_addr_t *addr)
+{
+    socket_addr_t *sockaddr = (socket_addr_t *)addr->handle;
+
+    sockaddr->refcount--;
+    if (sockaddr->refcount <= 0)
+    {
+        free(sockaddr);
+    }
+    free(addr);
+}
+
+static net_addr_t *NET_Socket_ResolveAddress(char *address)
+{
+    socket_addr_t *sockaddr;
+    net_addr_t *netaddr;
+    struct hostent *host;
+    char *addr_str;
+    char *port_str;
+    char addr_copy[256];
+    int port = DEFAULT_PORT;
+
+    // Parse address:port
+    strncpy(addr_copy, address, sizeof(addr_copy) - 1);
+    addr_copy[sizeof(addr_copy) - 1] = '\0';
+
+    addr_str = addr_copy;
+    port_str = strchr(addr_copy, ':');
+    if (port_str != NULL)
+    {
+        *port_str = '\0';
+        port_str++;
+        port = atoi(port_str);
+    }
+
+    sockaddr = malloc(sizeof(socket_addr_t));
+    if (sockaddr == NULL)
+        return NULL;
+
+    memset(&sockaddr->addr, 0, sizeof(sockaddr->addr));
+    sockaddr->addr.sin_family = AF_INET;
+    sockaddr->addr.sin_port = htons(port);
+    sockaddr->refcount = 1;
+
+    // Try as IP address first
+    if (inet_aton(addr_str, &sockaddr->addr.sin_addr) == 0)
+    {
+        // Try DNS lookup
+        host = gethostbyname(addr_str);
+        if (host == NULL)
+        {
+            fprintf(stderr, "NET_Socket_ResolveAddress: Failed to resolve '%s'\n", addr_str);
+            free(sockaddr);
+            return NULL;
+        }
+        memcpy(&sockaddr->addr.sin_addr, host->h_addr_list[0], host->h_length);
+    }
+
+    netaddr = malloc(sizeof(net_addr_t));
+    if (netaddr == NULL)
+    {
+        free(sockaddr);
+        return NULL;
+    }
+
+    netaddr->module = &net_socket_module;
+    netaddr->handle = sockaddr;
+
+    return netaddr;
+}
+
+void NET_Socket_Shutdown(void)
+{
+    if (client_socket >= 0)
+    {
+        close(client_socket);
+        client_socket = -1;
+    }
+    if (server_socket >= 0)
+    {
+        close(server_socket);
+        server_socket = -1;
+    }
+}
+
+net_module_t net_socket_module =
+{
+    NET_Socket_InitClient,
+    NET_Socket_InitServer,
+    NET_Socket_SendPacket,
+    NET_Socket_RecvPacket,
+    NET_Socket_AddrToString,
+    NET_Socket_FreeAddress,
+    NET_Socket_ResolveAddress,
+};
+
diff --git a/doomgeneric/net_socket.h b/doomgeneric/net_socket.h
new file mode 100644
index 0000000..69979b1
--- /dev/null
+++ b/doomgeneric/net_socket.h
@@ -0,0 +1,19 @@
+//
+// Copyright(C) 2026 WiFi Pineapple Pager port
+//
+// POSIX socket-based network module
+//
+
+#ifndef NET_SOCKET_H
+#define NET_SOCKET_H
+
+#include "net_defs.h"
+
+extern net_module_t net_socket_module;
+
+void NET_Socket_Shutdown(void);
+
+#endif /* #ifndef NET_SOCKET_H */
+
+
+
